#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Solaris

#include "Basic.hpp"

#include "Solaris_classes.hpp"
#include "Solaris_parameters.hpp"


namespace SDK
{

// Function Solaris.SolarisWeakMapLibrary.Call
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// TMap<struct FGenericKeyType, struct FGenericValueType>Map                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGenericKeyType                  Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisWeakMapLibrary::Call(const TMap<struct FGenericKeyType, struct FGenericValueType>& Map, const struct FGenericKeyType& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Call");

	Params::SolarisWeakMapLibrary_Call Parms{};

	Parms.Map = std::move(Map);
	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisWeakMapLibrary.CompletelyAssignedPersistentVarRefCall
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<struct FGenericKeyType, struct FGenericValueType>Map                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGenericKeyType                  Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisWeakMapLibrary::CompletelyAssignedPersistentVarRefCall(const class FString& Path, const TMap<struct FGenericKeyType, struct FGenericValueType>& Map, const struct FGenericKeyType& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CompletelyAssignedPersistentVarRefCall");

	Params::SolarisWeakMapLibrary_CompletelyAssignedPersistentVarRefCall Parms{};

	Parms.Path = std::move(Path);
	Parms.Map = std::move(Map);
	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisWeakMapLibrary.CompletelyAssignedRefCall
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// TMap<struct FGenericKeyType, struct FGenericValueType>Map                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGenericKeyType                  Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisWeakMapLibrary::CompletelyAssignedRefCall(const TMap<struct FGenericKeyType, struct FGenericValueType>& Map, const struct FGenericKeyType& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CompletelyAssignedRefCall");

	Params::SolarisWeakMapLibrary_CompletelyAssignedRefCall Parms{};

	Parms.Map = std::move(Map);
	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisWeakMapLibrary.FitsInPlayerMap
// (Final, Native, Static, Public)
// Parameters:
// struct FGenericValueType                Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void USolarisWeakMapLibrary::FitsInPlayerMap(const struct FGenericValueType& Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FitsInPlayerMap");

	Params::SolarisWeakMapLibrary_FitsInPlayerMap Parms{};

	Parms.Value = std::move(Value);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisWeakMapLibrary.PersistentVarCall
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// TMap<struct FGenericKeyType, struct FGenericValueType>Map                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGenericKeyType                  Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisWeakMapLibrary::PersistentVarCall(const TMap<struct FGenericKeyType, struct FGenericValueType>& Map, const struct FGenericKeyType& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PersistentVarCall");

	Params::SolarisWeakMapLibrary_PersistentVarCall Parms{};

	Parms.Map = std::move(Map);
	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisWeakMapLibrary.PersistentVarRefCall
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<struct FGenericKeyType, struct FGenericValueType>Map                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGenericKeyType                  Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisWeakMapLibrary::PersistentVarRefCall(const class FString& Path, const TMap<struct FGenericKeyType, struct FGenericValueType>& Map, const struct FGenericKeyType& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PersistentVarRefCall");

	Params::SolarisWeakMapLibrary_PersistentVarRefCall Parms{};

	Parms.Path = std::move(Path);
	Parms.Map = std::move(Map);
	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisWeakMapLibrary.RefCall
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// TMap<struct FGenericKeyType, struct FGenericValueType>Map                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGenericKeyType                  Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisWeakMapLibrary::RefCall(const TMap<struct FGenericKeyType, struct FGenericValueType>& Map, const struct FGenericKeyType& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RefCall");

	Params::SolarisWeakMapLibrary_RefCall Parms{};

	Parms.Map = std::move(Map);
	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisWeakMapLibrary.Type
// (Final, Native, Static, Public)
// Parameters:
// class UClass*                           KeyType                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           ValueType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisWeakMapLibrary::Type(class UClass* KeyType, class UClass* ValueType)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Type");

	Params::SolarisWeakMapLibrary_Type Parms{};

	Parms.KeyType = KeyType;
	Parms.ValueType = ValueType;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisArrayLibrary.Add
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// TArray<struct FGenericElementType>      Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGenericElementType              new_item                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 USolarisArrayLibrary::Add(const TArray<struct FGenericElementType>& Array, const struct FGenericElementType& new_item)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Add");

	Params::SolarisArrayLibrary_Add Parms{};

	Parms.Array = std::move(Array);
	Parms.new_item = std::move(new_item);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisArrayLibrary.Call
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// TArray<struct FGenericElementType>      Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int64                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisArrayLibrary::Call(const TArray<struct FGenericElementType>& Array, int64 Index_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Call");

	Params::SolarisArrayLibrary_Call Parms{};

	Parms.Array = std::move(Array);
	Parms.Index_0 = Index_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisArrayLibrary.Concat
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// TArray<struct FGenericElementType>      LHS                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FGenericElementType>      RHS                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FGenericElementType>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FGenericElementType> USolarisArrayLibrary::Concat(const TArray<struct FGenericElementType>& LHS, const TArray<struct FGenericElementType>& RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Concat");

	Params::SolarisArrayLibrary_Concat Parms{};

	Parms.LHS = std::move(LHS);
	Parms.RHS = std::move(RHS);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisArrayLibrary.ConcatEquals
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// TArray<struct FGenericElementType>      LHS                                                    (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FGenericElementType>      RHS                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FGenericElementType>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FGenericElementType> USolarisArrayLibrary::ConcatEquals(TArray<struct FGenericElementType>* LHS, const TArray<struct FGenericElementType>& RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ConcatEquals");

	Params::SolarisArrayLibrary_ConcatEquals Parms{};

	Parms.RHS = std::move(RHS);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (LHS != nullptr)
		*LHS = std::move(Parms.LHS);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisArrayLibrary.Empty
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// TArray<struct FGenericElementType>      Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void USolarisArrayLibrary::Empty(const TArray<struct FGenericElementType>& Array)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Empty");

	Params::SolarisArrayLibrary_Empty Parms{};

	Parms.Array = std::move(Array);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisArrayLibrary.Length
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// TArray<struct FGenericElementType>      Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 USolarisArrayLibrary::Length(const TArray<struct FGenericElementType>& Array)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Length");

	Params::SolarisArrayLibrary_Length Parms{};

	Parms.Array = std::move(Array);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisArrayLibrary.Move
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// TArray<struct FGenericElementType>      Target                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FGenericElementType>      Source                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void USolarisArrayLibrary::Move(const TArray<struct FGenericElementType>& Target, const TArray<struct FGenericElementType>& Source)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Move");

	Params::SolarisArrayLibrary_Move Parms{};

	Parms.Target = std::move(Target);
	Parms.Source = std::move(Source);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisArrayLibrary.RefCall
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// TArray<struct FGenericElementType>      Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int64                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisArrayLibrary::RefCall(const TArray<struct FGenericElementType>& Array, int64 Index_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RefCall");

	Params::SolarisArrayLibrary_RefCall Parms{};

	Parms.Array = std::move(Array);
	Parms.Index_0 = Index_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisArrayLibrary.UnsafeCall
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// TArray<struct FGenericElementType>      Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int64                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisArrayLibrary::UnsafeCall(const TArray<struct FGenericElementType>& Array, int64 Index_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("UnsafeCall");

	Params::SolarisArrayLibrary_UnsafeCall Parms{};

	Parms.Array = std::move(Array);
	Parms.Index_0 = Index_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisCoroutineLibrary.TaskCancel
// (Final, Native, Static, Public)
// Parameters:
// class UObject*                          task                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisCoroutineLibrary::TaskCancel(class UObject* task)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TaskCancel");

	Params::SolarisCoroutineLibrary_TaskCancel Parms{};

	Parms.task = task;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisCoroutineLibrary.TaskFree
// (Final, Native, Static, Public)
// Parameters:
// class UObject*                          task                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisCoroutineLibrary::TaskFree(class UObject* task)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TaskFree");

	Params::SolarisCoroutineLibrary_TaskFree Parms{};

	Parms.task = task;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisCoroutineLibrary.TaskGetReturnProperty
// (Final, Native, Static, Public)
// Parameters:
// class UObject*                          task                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisCoroutineLibrary::TaskGetReturnProperty(class UObject* task)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TaskGetReturnProperty");

	Params::SolarisCoroutineLibrary_TaskGetReturnProperty Parms{};

	Parms.task = task;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisCoroutineLibrary.TaskGetState
// (Final, Native, Static, Public)
// Parameters:
// class UObject*                          task                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 USolarisCoroutineLibrary::TaskGetState(class UObject* task)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TaskGetState");

	Params::SolarisCoroutineLibrary_TaskGetState Parms{};

	Parms.task = task;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisCoroutineLibrary.TaskMake
// (Final, Native, Static, Public)
// Parameters:
// class UClass*                           Type                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Caller                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   CallerResumeState                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   CallerCancelState                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          OwnerInstance                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* USolarisCoroutineLibrary::TaskMake(class UClass* Type, class UObject* Caller, int64 CallerResumeState, int64 CallerCancelState, class UObject* OwnerInstance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TaskMake");

	Params::SolarisCoroutineLibrary_TaskMake Parms{};

	Parms.Type = Type;
	Parms.Caller = Caller;
	Parms.CallerResumeState = CallerResumeState;
	Parms.CallerCancelState = CallerCancelState;
	Parms.OwnerInstance = OwnerInstance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisMapLibrary.Add
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// TMap<struct FGenericKeyType, struct FGenericValueType>Map                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGenericKeyType                  Key                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGenericValueType                Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void USolarisMapLibrary::Add(const TMap<struct FGenericKeyType, struct FGenericValueType>& Map, const struct FGenericKeyType& Key, const struct FGenericValueType& Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Add");

	Params::SolarisMapLibrary_Add Parms{};

	Parms.Map = std::move(Map);
	Parms.Key = std::move(Key);
	Parms.Value = std::move(Value);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisMapLibrary.Concat
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// TMap<struct FGenericKeyType, struct FGenericValueType>LHS                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TMap<struct FGenericKeyType, struct FGenericValueType>RHS                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TMap<struct FGenericKeyType, struct FGenericValueType>ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<struct FGenericKeyType, struct FGenericValueType> USolarisMapLibrary::Concat(const TMap<struct FGenericKeyType, struct FGenericValueType>& LHS, const TMap<struct FGenericKeyType, struct FGenericValueType>& RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Concat");

	Params::SolarisMapLibrary_Concat Parms{};

	Parms.LHS = std::move(LHS);
	Parms.RHS = std::move(RHS);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisMapLibrary.GetKeyByIndex
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// TMap<struct FGenericKeyType, struct FGenericValueType>Map                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int64                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGenericKeyType                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGenericKeyType USolarisMapLibrary::GetKeyByIndex(const TMap<struct FGenericKeyType, struct FGenericValueType>& Map, int64 Index_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetKeyByIndex");

	Params::SolarisMapLibrary_GetKeyByIndex Parms{};

	Parms.Map = std::move(Map);
	Parms.Index_0 = Index_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisMapLibrary.GetNextValidIndex
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// TMap<struct FGenericKeyType, struct FGenericValueType>Map                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int64                                   InitialIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 USolarisMapLibrary::GetNextValidIndex(const TMap<struct FGenericKeyType, struct FGenericValueType>& Map, int64 InitialIndex)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetNextValidIndex");

	Params::SolarisMapLibrary_GetNextValidIndex Parms{};

	Parms.Map = std::move(Map);
	Parms.InitialIndex = InitialIndex;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisMapLibrary.GetValueByIndex
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// TMap<struct FGenericKeyType, struct FGenericValueType>Map                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int64                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGenericValueType                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FGenericValueType USolarisMapLibrary::GetValueByIndex(const TMap<struct FGenericKeyType, struct FGenericValueType>& Map, int64 Index_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetValueByIndex");

	Params::SolarisMapLibrary_GetValueByIndex Parms{};

	Parms.Map = std::move(Map);
	Parms.Index_0 = Index_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisMapLibrary.InitMap
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// TMap<struct FGenericKeyType, struct FGenericValueType>Map                                                    (Parm, OutParm, NativeAccessSpecifierPublic)

void USolarisMapLibrary::InitMap(TMap<struct FGenericKeyType, struct FGenericValueType>* Map)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("InitMap");

	Params::SolarisMapLibrary_InitMap Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Map != nullptr)
		*Map = std::move(Parms.Map);
}


// Function Solaris.SolarisMapLibrary.Length
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// TMap<struct FGenericKeyType, struct FGenericValueType>Map                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 USolarisMapLibrary::Length(const TMap<struct FGenericKeyType, struct FGenericValueType>& Map)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Length");

	Params::SolarisMapLibrary_Length Parms{};

	Parms.Map = std::move(Map);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisMapLibrary.Move
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// TMap<struct FGenericKeyType, struct FGenericValueType>Dest                                                   (Parm, OutParm, NativeAccessSpecifierPublic)
// TMap<struct FGenericKeyType, struct FGenericValueType>Src                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USolarisMapLibrary::Move(TMap<struct FGenericKeyType, struct FGenericValueType>* Dest, const TMap<struct FGenericKeyType, struct FGenericValueType>& Src)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Move");

	Params::SolarisMapLibrary_Move Parms{};

	Parms.Src = std::move(Src);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Dest != nullptr)
		*Dest = std::move(Parms.Dest);
}


// Function Solaris.SolarisMathLibrary_Bool.Query
// (Final, Native, Static, Public)

void USolarisMathLibrary_Bool::Query()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Query");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function Solaris.SolarisMathLibrary_Int.abs
// (Final, Native, Static, Public)
// Parameters:
// int64                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisMathLibrary_Int::abs(int64 Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("abs");

	Params::SolarisMathLibrary_Int_abs Parms{};

	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisMathLibrary_Int.Add
// (Final, Native, Static, Public)
// Parameters:
// int64                                   LHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisMathLibrary_Int::Add(int64 LHS, int64 RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Add");

	Params::SolarisMathLibrary_Int_Add Parms{};

	Parms.LHS = LHS;
	Parms.RHS = RHS;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisMathLibrary_Int.AddEquals
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// int64                                   LHS                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisMathLibrary_Int::AddEquals(int64* LHS, int64 RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddEquals");

	Params::SolarisMathLibrary_Int_AddEquals Parms{};

	Parms.RHS = RHS;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (LHS != nullptr)
		*LHS = Parms.LHS;
}


// Function Solaris.SolarisMathLibrary_Int.CheckConstrainedInt
// (Final, Native, Static, Public)
// Parameters:
// int64                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisMathLibrary_Int::CheckConstrainedInt(int64 Min, int64 Max, int64 Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CheckConstrainedInt");

	Params::SolarisMathLibrary_Int_CheckConstrainedInt Parms{};

	Parms.Min = Min;
	Parms.Max = Max;
	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisMathLibrary_Int.Divide
// (Final, Native, Static, Public)
// Parameters:
// int64                                   LHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisMathLibrary_Int::Divide(int64 LHS, int64 RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Divide");

	Params::SolarisMathLibrary_Int_Divide Parms{};

	Parms.LHS = LHS;
	Parms.RHS = RHS;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisMathLibrary_Int.Greater
// (Final, Native, Static, Public)
// Parameters:
// int64                                   LHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisMathLibrary_Int::Greater(int64 LHS, int64 RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Greater");

	Params::SolarisMathLibrary_Int_Greater Parms{};

	Parms.LHS = LHS;
	Parms.RHS = RHS;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisMathLibrary_Int.GreaterEqual
// (Final, Native, Static, Public)
// Parameters:
// int64                                   LHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisMathLibrary_Int::GreaterEqual(int64 LHS, int64 RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GreaterEqual");

	Params::SolarisMathLibrary_Int_GreaterEqual Parms{};

	Parms.LHS = LHS;
	Parms.RHS = RHS;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisMathLibrary_Int.Less
// (Final, Native, Static, Public)
// Parameters:
// int64                                   LHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisMathLibrary_Int::Less(int64 LHS, int64 RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Less");

	Params::SolarisMathLibrary_Int_Less Parms{};

	Parms.LHS = LHS;
	Parms.RHS = RHS;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisMathLibrary_Int.LessEqual
// (Final, Native, Static, Public)
// Parameters:
// int64                                   LHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisMathLibrary_Int::LessEqual(int64 LHS, int64 RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LessEqual");

	Params::SolarisMathLibrary_Int_LessEqual Parms{};

	Parms.LHS = LHS;
	Parms.RHS = RHS;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisMathLibrary_Int.Multiply
// (Final, Native, Static, Public)
// Parameters:
// int64                                   LHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisMathLibrary_Int::Multiply(int64 LHS, int64 RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Multiply");

	Params::SolarisMathLibrary_Int_Multiply Parms{};

	Parms.LHS = LHS;
	Parms.RHS = RHS;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisMathLibrary_Int.MultiplyEquals
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// int64                                   LHS                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisMathLibrary_Int::MultiplyEquals(int64* LHS, int64 RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MultiplyEquals");

	Params::SolarisMathLibrary_Int_MultiplyEquals Parms{};

	Parms.RHS = RHS;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (LHS != nullptr)
		*LHS = Parms.LHS;
}


// Function Solaris.SolarisMathLibrary_Int.Negate
// (Final, Native, Static, Public)
// Parameters:
// int64                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisMathLibrary_Int::Negate(int64 Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Negate");

	Params::SolarisMathLibrary_Int_Negate Parms{};

	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisMathLibrary_Int.PredicateEqual
// (Final, Native, Static, Public)
// Parameters:
// int64                                   LHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USolarisMathLibrary_Int::PredicateEqual(int64 LHS, int64 RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PredicateEqual");

	Params::SolarisMathLibrary_Int_PredicateEqual Parms{};

	Parms.LHS = LHS;
	Parms.RHS = RHS;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisMathLibrary_Int.PredicateGreater
// (Final, Native, Static, Public)
// Parameters:
// int64                                   LHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USolarisMathLibrary_Int::PredicateGreater(int64 LHS, int64 RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PredicateGreater");

	Params::SolarisMathLibrary_Int_PredicateGreater Parms{};

	Parms.LHS = LHS;
	Parms.RHS = RHS;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisMathLibrary_Int.PredicateGreaterEqual
// (Final, Native, Static, Public)
// Parameters:
// int64                                   LHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USolarisMathLibrary_Int::PredicateGreaterEqual(int64 LHS, int64 RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PredicateGreaterEqual");

	Params::SolarisMathLibrary_Int_PredicateGreaterEqual Parms{};

	Parms.LHS = LHS;
	Parms.RHS = RHS;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisMathLibrary_Int.PredicateLess
// (Final, Native, Static, Public)
// Parameters:
// int64                                   LHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USolarisMathLibrary_Int::PredicateLess(int64 LHS, int64 RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PredicateLess");

	Params::SolarisMathLibrary_Int_PredicateLess Parms{};

	Parms.LHS = LHS;
	Parms.RHS = RHS;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisMathLibrary_Int.PredicateLessEqual
// (Final, Native, Static, Public)
// Parameters:
// int64                                   LHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USolarisMathLibrary_Int::PredicateLessEqual(int64 LHS, int64 RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PredicateLessEqual");

	Params::SolarisMathLibrary_Int_PredicateLessEqual Parms{};

	Parms.LHS = LHS;
	Parms.RHS = RHS;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisMathLibrary_Int.PredicateNotEqual
// (Final, Native, Static, Public)
// Parameters:
// int64                                   LHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USolarisMathLibrary_Int::PredicateNotEqual(int64 LHS, int64 RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PredicateNotEqual");

	Params::SolarisMathLibrary_Int_PredicateNotEqual Parms{};

	Parms.LHS = LHS;
	Parms.RHS = RHS;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisMathLibrary_Int.Subtract
// (Final, Native, Static, Public)
// Parameters:
// int64                                   LHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisMathLibrary_Int::Subtract(int64 LHS, int64 RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Subtract");

	Params::SolarisMathLibrary_Int_Subtract Parms{};

	Parms.LHS = LHS;
	Parms.RHS = RHS;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisMathLibrary_Int.SubtractEquals
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// int64                                   LHS                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisMathLibrary_Int::SubtractEquals(int64* LHS, int64 RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SubtractEquals");

	Params::SolarisMathLibrary_Int_SubtractEquals Parms{};

	Parms.RHS = RHS;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (LHS != nullptr)
		*LHS = Parms.LHS;
}


// Function Solaris.SolarisMathLibrary_Int.UncheckedConvertI32I64
// (Final, Native, Static, Public)
// Parameters:
// int64                                   RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USolarisMathLibrary_Int::UncheckedConvertI32I64(int64 RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("UncheckedConvertI32I64");

	Params::SolarisMathLibrary_Int_UncheckedConvertI32I64 Parms{};

	Parms.RHS = RHS;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisMathLibrary_Rational.ceil
// (Final, Native, Static, Public)
// Parameters:
// struct FVerseRational                   Val                                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USolarisMathLibrary_Rational::ceil(const struct FVerseRational& Val)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ceil");

	Params::SolarisMathLibrary_Rational_ceil Parms{};

	Parms.Val = std::move(Val);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisMathLibrary_Rational.floor
// (Final, Native, Static, Public)
// Parameters:
// struct FVerseRational                   Val                                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USolarisMathLibrary_Rational::floor(const struct FVerseRational& Val)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("floor");

	Params::SolarisMathLibrary_Rational_floor Parms{};

	Parms.Val = std::move(Val);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisMathLibrary_Float.abs
// (Final, Native, Static, Public)
// Parameters:
// double                                  Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double USolarisMathLibrary_Float::abs(double Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("abs");

	Params::SolarisMathLibrary_Float_abs Parms{};

	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisMathLibrary_Float.Add
// (Final, Native, Static, Public)
// Parameters:
// double                                  LHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double USolarisMathLibrary_Float::Add(double LHS, double RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Add");

	Params::SolarisMathLibrary_Float_Add Parms{};

	Parms.LHS = LHS;
	Parms.RHS = RHS;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisMathLibrary_Float.AddEquals
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// double                                  LHS                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double USolarisMathLibrary_Float::AddEquals(double* LHS, double RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddEquals");

	Params::SolarisMathLibrary_Float_AddEquals Parms{};

	Parms.RHS = RHS;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (LHS != nullptr)
		*LHS = Parms.LHS;

	return Parms.ReturnValue;
}


// Function Solaris.SolarisMathLibrary_Float.CheckConstrainedFloat
// (Final, Native, Static, Public)
// Parameters:
// double                                  Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisMathLibrary_Float::CheckConstrainedFloat(double Min, double Max, double Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CheckConstrainedFloat");

	Params::SolarisMathLibrary_Float_CheckConstrainedFloat Parms{};

	Parms.Min = Min;
	Parms.Max = Max;
	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisMathLibrary_Float.Divide
// (Final, Native, Static, Public)
// Parameters:
// double                                  LHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double USolarisMathLibrary_Float::Divide(double LHS, double RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Divide");

	Params::SolarisMathLibrary_Float_Divide Parms{};

	Parms.LHS = LHS;
	Parms.RHS = RHS;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisMathLibrary_Float.DivideEquals
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// double                                  LHS                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double USolarisMathLibrary_Float::DivideEquals(double* LHS, double RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DivideEquals");

	Params::SolarisMathLibrary_Float_DivideEquals Parms{};

	Parms.RHS = RHS;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (LHS != nullptr)
		*LHS = Parms.LHS;

	return Parms.ReturnValue;
}


// Function Solaris.SolarisMathLibrary_Float.Greater
// (Final, Native, Static, Public)
// Parameters:
// double                                  LHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisMathLibrary_Float::Greater(double LHS, double RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Greater");

	Params::SolarisMathLibrary_Float_Greater Parms{};

	Parms.LHS = LHS;
	Parms.RHS = RHS;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisMathLibrary_Float.GreaterEqual
// (Final, Native, Static, Public)
// Parameters:
// double                                  LHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisMathLibrary_Float::GreaterEqual(double LHS, double RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GreaterEqual");

	Params::SolarisMathLibrary_Float_GreaterEqual Parms{};

	Parms.LHS = LHS;
	Parms.RHS = RHS;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisMathLibrary_Float.Less
// (Final, Native, Static, Public)
// Parameters:
// double                                  LHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisMathLibrary_Float::Less(double LHS, double RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Less");

	Params::SolarisMathLibrary_Float_Less Parms{};

	Parms.LHS = LHS;
	Parms.RHS = RHS;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisMathLibrary_Float.LessEqual
// (Final, Native, Static, Public)
// Parameters:
// double                                  LHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisMathLibrary_Float::LessEqual(double LHS, double RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LessEqual");

	Params::SolarisMathLibrary_Float_LessEqual Parms{};

	Parms.LHS = LHS;
	Parms.RHS = RHS;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisMathLibrary_Float.Multiply
// (Final, Native, Static, Public)
// Parameters:
// double                                  LHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double USolarisMathLibrary_Float::Multiply(double LHS, double RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Multiply");

	Params::SolarisMathLibrary_Float_Multiply Parms{};

	Parms.LHS = LHS;
	Parms.RHS = RHS;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisMathLibrary_Float.MultiplyEquals
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// double                                  LHS                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double USolarisMathLibrary_Float::MultiplyEquals(double* LHS, double RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MultiplyEquals");

	Params::SolarisMathLibrary_Float_MultiplyEquals Parms{};

	Parms.RHS = RHS;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (LHS != nullptr)
		*LHS = Parms.LHS;

	return Parms.ReturnValue;
}


// Function Solaris.SolarisMathLibrary_Float.MultiplyFloatInt
// (Final, Native, Static, Public)
// Parameters:
// double                                  LHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double USolarisMathLibrary_Float::MultiplyFloatInt(double LHS, int64 RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MultiplyFloatInt");

	Params::SolarisMathLibrary_Float_MultiplyFloatInt Parms{};

	Parms.LHS = LHS;
	Parms.RHS = RHS;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisMathLibrary_Float.MultiplyIntFloat
// (Final, Native, Static, Public)
// Parameters:
// int64                                   LHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double USolarisMathLibrary_Float::MultiplyIntFloat(int64 LHS, double RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MultiplyIntFloat");

	Params::SolarisMathLibrary_Float_MultiplyIntFloat Parms{};

	Parms.LHS = LHS;
	Parms.RHS = RHS;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisMathLibrary_Float.Negate
// (Final, Native, Static, Public)
// Parameters:
// double                                  Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double USolarisMathLibrary_Float::Negate(double Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Negate");

	Params::SolarisMathLibrary_Float_Negate Parms{};

	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisMathLibrary_Float.Subtract
// (Final, Native, Static, Public)
// Parameters:
// double                                  LHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double USolarisMathLibrary_Float::Subtract(double LHS, double RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Subtract");

	Params::SolarisMathLibrary_Float_Subtract Parms{};

	Parms.LHS = LHS;
	Parms.RHS = RHS;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisMathLibrary_Float.SubtractEquals
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// double                                  LHS                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double USolarisMathLibrary_Float::SubtractEquals(double* LHS, double RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SubtractEquals");

	Params::SolarisMathLibrary_Float_SubtractEquals Parms{};

	Parms.RHS = RHS;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (LHS != nullptr)
		*LHS = Parms.LHS;

	return Parms.ReturnValue;
}


// Function Solaris.SolarisMathLibrary_String.Add
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// int32                                   String                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int8                                    Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisMathLibrary_String::Add(const int32& String, int8 Character)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Add");

	Params::SolarisMathLibrary_String_Add Parms{};

	Parms.String = String;
	Parms.Character = Character;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisMathLibrary_String.Call
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// int32                                   String                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisMathLibrary_String::Call(const int32& String, int64 Index_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Call");

	Params::SolarisMathLibrary_String_Call Parms{};

	Parms.String = String;
	Parms.Index_0 = Index_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisMathLibrary_String.Concat
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// int32                                   LHS                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RHS                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USolarisMathLibrary_String::Concat(const int32& LHS, const int32& RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Concat");

	Params::SolarisMathLibrary_String_Concat Parms{};

	Parms.LHS = LHS;
	Parms.RHS = RHS;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisMathLibrary_String.ConcatEquals
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// int32                                   LHS                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RHS                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USolarisMathLibrary_String::ConcatEquals(int32* LHS, const int32& RHS)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ConcatEquals");

	Params::SolarisMathLibrary_String_ConcatEquals Parms{};

	Parms.RHS = RHS;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (LHS != nullptr)
		*LHS = Parms.LHS;

	return Parms.ReturnValue;
}


// Function Solaris.SolarisMathLibrary_String.Length
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// int32                                   Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 USolarisMathLibrary_String::Length(const int32& Array)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Length");

	Params::SolarisMathLibrary_String_Length Parms{};

	Parms.Array = Array;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisMathLibrary_String.Make
// (Final, Native, Static, Public)

void USolarisMathLibrary_String::Make()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Make");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function Solaris.SolarisMathLibrary_String.MakeLiteral
// (Final, Native, Static, Public)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USolarisMathLibrary_String::MakeLiteral()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeLiteral");

	Params::SolarisMathLibrary_String_MakeLiteral Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisMathLibrary_String.Move
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// int32                                   Destination                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Source                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisMathLibrary_String::Move(const int32& Destination, const int32& Source)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Move");

	Params::SolarisMathLibrary_String_Move Parms{};

	Parms.Destination = Destination;
	Parms.Source = Source;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisMathLibrary_String.RefCall
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// int32                                   String                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisMathLibrary_String::RefCall(const int32& String, int64 Index_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RefCall");

	Params::SolarisMathLibrary_String_RefCall Parms{};

	Parms.String = String;
	Parms.Index_0 = Index_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisMathLibrary_String.UncheckedCall
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// int32                                   String                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisMathLibrary_String::UncheckedCall(const int32& String, int64 Index_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("UncheckedCall");

	Params::SolarisMathLibrary_String_UncheckedCall Parms{};

	Parms.String = String;
	Parms.Index_0 = Index_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisMathLibrary_Option.Make
// (Final, Native, Static, Public)

void USolarisMathLibrary_Option::Make()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Make");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function Solaris.SolarisMathLibrary_Option.Query
// (Final, Native, Static, Public)

void USolarisMathLibrary_Option::Query()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Query");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function Solaris.SolarisUtilLibrary.AddPropertyToSubobjectExclusionList
// (Final, Native, Static, Public)
// Parameters:
// int64                                   InstancingGraph                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   Property                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisUtilLibrary::AddPropertyToSubobjectExclusionList(int64 InstancingGraph, int64 Property)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddPropertyToSubobjectExclusionList");

	Params::SolarisUtilLibrary_AddPropertyToSubobjectExclusionList Parms{};

	Parms.InstancingGraph = InstancingGraph;
	Parms.Property = Property;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisUtilLibrary.Addressof
// (Final, Native, Static, Public)
// Parameters:
// int64                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 USolarisUtilLibrary::Addressof(int64 Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Addressof");

	Params::SolarisUtilLibrary_Addressof Parms{};

	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisUtilLibrary.CallFinalFunctionWithContext
// (Final, Native, Static, Public)

void USolarisUtilLibrary::CallFinalFunctionWithContext()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CallFinalFunctionWithContext");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function Solaris.SolarisUtilLibrary.CallFunction
// (Final, Native, Static, Public)

void USolarisUtilLibrary::CallFunction()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CallFunction");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function Solaris.SolarisUtilLibrary.Dereference
// (Final, Native, Static, Public)
// Parameters:
// int64                                   Reference                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 USolarisUtilLibrary::Dereference(int64 Reference)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Dereference");

	Params::SolarisUtilLibrary_Dereference Parms{};

	Parms.Reference = Reference;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisUtilLibrary.GetCurrentlyInstantiatedObject
// (Final, Native, Static, Public)
// Parameters:
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* USolarisUtilLibrary::GetCurrentlyInstantiatedObject()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCurrentlyInstantiatedObject");

	Params::SolarisUtilLibrary_GetCurrentlyInstantiatedObject Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisUtilLibrary.GetFunctionForInterfaceMethod
// (Final, Native, Static, Public)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             MethodName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisUtilLibrary::GetFunctionForInterfaceMethod(class UObject* Object, class FName MethodName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetFunctionForInterfaceMethod");

	Params::SolarisUtilLibrary_GetFunctionForInterfaceMethod Parms{};

	Parms.Object = Object;
	Parms.MethodName = MethodName;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisUtilLibrary.GetOptionValue
// (Final, Native, Static, Public)
// Parameters:
// int64                                   Option                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 USolarisUtilLibrary::GetOptionValue(int64 Option)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetOptionValue");

	Params::SolarisUtilLibrary_GetOptionValue Parms{};

	Parms.Option = Option;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisUtilLibrary.HasInterface
// (Final, Native, Static, Public)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           InterfaceClass                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USolarisUtilLibrary::HasInterface(class UObject* Object, class UClass* InterfaceClass)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("HasInterface");

	Params::SolarisUtilLibrary_HasInterface Parms{};

	Parms.Object = Object;
	Parms.InterfaceClass = InterfaceClass;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisUtilLibrary.InstanceFunction
// (Final, Native, Static, Public)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             MethodName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisUtilLibrary::InstanceFunction(class UObject* Object, class FName MethodName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("InstanceFunction");

	Params::SolarisUtilLibrary_InstanceFunction Parms{};

	Parms.Object = Object;
	Parms.MethodName = MethodName;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisUtilLibrary.InstantiateObject
// (Final, Native, Static, Public)
// Parameters:
// class UClass*                           Class_0                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   InstancingGraph                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarisUtilLibrary::InstantiateObject(class UClass* Class_0, int64 InstancingGraph)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("InstantiateObject");

	Params::SolarisUtilLibrary_InstantiateObject Parms{};

	Parms.Class_0 = Class_0;
	Parms.InstancingGraph = InstancingGraph;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.SolarisUtilLibrary.IsNonNullObject
// (Final, Native, Static, Public)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USolarisUtilLibrary::IsNonNullObject(class UObject* Object)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsNonNullObject");

	Params::SolarisUtilLibrary_IsNonNullObject Parms{};

	Parms.Object = Object;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisUtilLibrary.IsOptionSet
// (Final, Native, Static, Public)
// Parameters:
// int64                                   Option                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USolarisUtilLibrary::IsOptionSet(int64 Option)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsOptionSet");

	Params::SolarisUtilLibrary_IsOptionSet Parms{};

	Parms.Option = Option;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisUtilLibrary.MakeOptionFromValue
// (Final, Native, Static, Public)
// Parameters:
// class UObject*                          Property                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USolarisUtilLibrary::MakeOptionFromValue(class UObject* Property, int64 Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeOptionFromValue");

	Params::SolarisUtilLibrary_MakeOptionFromValue Parms{};

	Parms.Property = Property;
	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisUtilLibrary.MakeUnsetOption
// (Final, Native, Static, Public)
// Parameters:
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 USolarisUtilLibrary::MakeUnsetOption()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeUnsetOption");

	Params::SolarisUtilLibrary_MakeUnsetOption Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisUtilLibrary.ObjectHasNoFlags
// (Final, Native, Static, Public)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Flags_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USolarisUtilLibrary::ObjectHasNoFlags(class UObject* Object, int32 Flags_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ObjectHasNoFlags");

	Params::SolarisUtilLibrary_ObjectHasNoFlags Parms{};

	Parms.Object = Object;
	Parms.Flags_0 = Flags_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisUtilLibrary.ReferenceIsValid
// (Final, Native, Static, Public)
// Parameters:
// int64                                   Reference                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USolarisUtilLibrary::ReferenceIsValid(int64 Reference)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ReferenceIsValid");

	Params::SolarisUtilLibrary_ReferenceIsValid Parms{};

	Parms.Reference = Reference;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.SolarisUtilLibrary.ReplaceOptionValue
// (Final, Native, Static, Public)
// Parameters:
// int64                                   ResultProperty                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   Option                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 USolarisUtilLibrary::ReplaceOptionValue(int64 ResultProperty, int64 Option, int64 Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ReplaceOptionValue");

	Params::SolarisUtilLibrary_ReplaceOptionValue Parms{};

	Parms.ResultProperty = ResultProperty;
	Parms.Option = Option;
	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Solaris.VerseDynamicallyTypedValueLibrary.ConvertFromDynamicallyTypedValue
// (Final, Native, Static, Public)
// Parameters:
// int32                                   RuntimeType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVerseDynamicallyTypedValueLibrary::ConvertFromDynamicallyTypedValue(int32 RuntimeType, int32 Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ConvertFromDynamicallyTypedValue");

	Params::VerseDynamicallyTypedValueLibrary_ConvertFromDynamicallyTypedValue Parms{};

	Parms.RuntimeType = RuntimeType;
	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.VerseDynamicallyTypedValueLibrary.ConvertToDynamicallyTypedValue
// (Final, Native, Static, Public)
// Parameters:
// int32                                   RuntimeType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVerseDynamicallyTypedValueLibrary::ConvertToDynamicallyTypedValue(int32 RuntimeType, int32 Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ConvertToDynamicallyTypedValue");

	Params::VerseDynamicallyTypedValueLibrary_ConvertToDynamicallyTypedValue Parms{};

	Parms.RuntimeType = RuntimeType;
	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.VerseDynamicallyTypedValueLibrary.Equal
// (Final, Native, Static, Public)
// Parameters:
// int32                                   Left                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Right                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVerseDynamicallyTypedValueLibrary::Equal(int32 Left, int32 Right)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Equal");

	Params::VerseDynamicallyTypedValueLibrary_Equal Parms{};

	Parms.Left = Left;
	Parms.Right = Right;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.VerseDynamicallyTypedValueLibrary.MakeRuntimeTypeArray
// (Final, Native, Static, Public)
// Parameters:
// int32                                   ElementType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVerseDynamicallyTypedValueLibrary::MakeRuntimeTypeArray(int32 ElementType)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeRuntimeTypeArray");

	Params::VerseDynamicallyTypedValueLibrary_MakeRuntimeTypeArray Parms{};

	Parms.ElementType = ElementType;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.VerseDynamicallyTypedValueLibrary.MakeRuntimeTypeChar32
// (Final, Native, Static, Public)

void UVerseDynamicallyTypedValueLibrary::MakeRuntimeTypeChar32()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeRuntimeTypeChar32");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function Solaris.VerseDynamicallyTypedValueLibrary.MakeRuntimeTypeChar8
// (Final, Native, Static, Public)

void UVerseDynamicallyTypedValueLibrary::MakeRuntimeTypeChar8()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeRuntimeTypeChar8");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function Solaris.VerseDynamicallyTypedValueLibrary.MakeRuntimeTypeClass
// (Final, Native, Static, Public)

void UVerseDynamicallyTypedValueLibrary::MakeRuntimeTypeClass()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeRuntimeTypeClass");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function Solaris.VerseDynamicallyTypedValueLibrary.MakeRuntimeTypeDynamic
// (Final, Native, Static, Public)

void UVerseDynamicallyTypedValueLibrary::MakeRuntimeTypeDynamic()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeRuntimeTypeDynamic");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function Solaris.VerseDynamicallyTypedValueLibrary.MakeRuntimeTypeEnum
// (Final, Native, Static, Public)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVerseDynamicallyTypedValueLibrary::MakeRuntimeTypeEnum(class FName Name_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeRuntimeTypeEnum");

	Params::VerseDynamicallyTypedValueLibrary_MakeRuntimeTypeEnum Parms{};

	Parms.Name_0 = Name_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.VerseDynamicallyTypedValueLibrary.MakeRuntimeTypeFloat
// (Final, Native, Static, Public)

void UVerseDynamicallyTypedValueLibrary::MakeRuntimeTypeFloat()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeRuntimeTypeFloat");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function Solaris.VerseDynamicallyTypedValueLibrary.MakeRuntimeTypeFunction
// (Final, Native, Static, Public)

void UVerseDynamicallyTypedValueLibrary::MakeRuntimeTypeFunction()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeRuntimeTypeFunction");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function Solaris.VerseDynamicallyTypedValueLibrary.MakeRuntimeTypeInt64
// (Final, Native, Static, Public)

void UVerseDynamicallyTypedValueLibrary::MakeRuntimeTypeInt64()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeRuntimeTypeInt64");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function Solaris.VerseDynamicallyTypedValueLibrary.MakeRuntimeTypeLogic
// (Final, Native, Static, Public)

void UVerseDynamicallyTypedValueLibrary::MakeRuntimeTypeLogic()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeRuntimeTypeLogic");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function Solaris.VerseDynamicallyTypedValueLibrary.MakeRuntimeTypeMap
// (Final, Native, Static, Public)
// Parameters:
// int32                                   KeyType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ValueType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVerseDynamicallyTypedValueLibrary::MakeRuntimeTypeMap(int32 KeyType, int32 ValueType)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeRuntimeTypeMap");

	Params::VerseDynamicallyTypedValueLibrary_MakeRuntimeTypeMap Parms{};

	Parms.KeyType = KeyType;
	Parms.ValueType = ValueType;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.VerseDynamicallyTypedValueLibrary.MakeRuntimeTypeObject
// (Final, Native, Static, Public)

void UVerseDynamicallyTypedValueLibrary::MakeRuntimeTypeObject()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeRuntimeTypeObject");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function Solaris.VerseDynamicallyTypedValueLibrary.MakeRuntimeTypeOption
// (Final, Native, Static, Public)
// Parameters:
// int32                                   ValueType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVerseDynamicallyTypedValueLibrary::MakeRuntimeTypeOption(int32 ValueType)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeRuntimeTypeOption");

	Params::VerseDynamicallyTypedValueLibrary_MakeRuntimeTypeOption Parms{};

	Parms.ValueType = ValueType;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.VerseDynamicallyTypedValueLibrary.MakeRuntimeTypeString
// (Final, Native, Static, Public)

void UVerseDynamicallyTypedValueLibrary::MakeRuntimeTypeString()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeRuntimeTypeString");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function Solaris.VerseDynamicallyTypedValueLibrary.MakeRuntimeTypeStruct
// (Final, Native, Static, Public)
// Parameters:
// class UStruct*                          Struct                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVerseDynamicallyTypedValueLibrary::MakeRuntimeTypeStruct(class UStruct* Struct)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeRuntimeTypeStruct");

	Params::VerseDynamicallyTypedValueLibrary_MakeRuntimeTypeStruct Parms{};

	Parms.Struct = Struct;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.VerseDynamicallyTypedValueLibrary.MakeRuntimeTypeTuple
// (Final, Native, Static, Public)
// Parameters:
// TArray<int32>                           ValueType                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UVerseDynamicallyTypedValueLibrary::MakeRuntimeTypeTuple(const TArray<int32>& ValueType)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeRuntimeTypeTuple");

	Params::VerseDynamicallyTypedValueLibrary_MakeRuntimeTypeTuple Parms{};

	Parms.ValueType = std::move(ValueType);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Solaris.VerseDynamicallyTypedValueLibrary.NotEqual
// (Final, Native, Static, Public)
// Parameters:
// int32                                   Left                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Right                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVerseDynamicallyTypedValueLibrary::NotEqual(int32 Left, int32 Right)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NotEqual");

	Params::VerseDynamicallyTypedValueLibrary_NotEqual Parms{};

	Parms.Left = Left;
	Parms.Right = Right;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}

}

