#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: StateTreeModule

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "AIModule_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "StructUtils_structs.hpp"


namespace SDK
{

// Enum StateTreeModule.EStateTreeBreakpointType
// NumValues: 0x0004
enum class EStateTreeBreakpointType : uint8
{
	Unset                                    = 0,
	OnEnter                                  = 1,
	OnExit                                   = 2,
	OnTransition                             = 3,
};

// Enum StateTreeModule.EStateTreeUpdatePhase
// NumValues: 0x000F
enum class EStateTreeUpdatePhase : uint8
{
	Unset                                    = 0,
	StartTree                                = 1,
	StopTree                                 = 2,
	StartGlobalTasks                         = 3,
	StopGlobalTasks                          = 4,
	TickStateTree                            = 5,
	ApplyTransitions                         = 6,
	TriggerTransitions                       = 7,
	TickingGlobalTasks                       = 8,
	TickingTasks                             = 9,
	TransitionConditions                     = 10,
	StateSelection                           = 11,
	EnterConditions                          = 12,
	EnterStates                              = 13,
	ExitStates                               = 14,
};

// Enum StateTreeModule.EStateTreeRunStatus
// NumValues: 0x0005
enum class EStateTreeRunStatus : uint8
{
	Running                                  = 0,
	Failed                                   = 1,
	Succeeded                                = 2,
	Stopped                                  = 3,
	Unset                                    = 4,
};

// Enum StateTreeModule.EStateTreeStateChangeType
// NumValues: 0x0003
enum class EStateTreeStateChangeType : uint8
{
	None                                     = 0,
	Changed                                  = 1,
	Sustained                                = 2,
};

// Enum StateTreeModule.EStateTreeConditionEvaluationMode
// NumValues: 0x0003
enum class EStateTreeConditionEvaluationMode : uint8
{
	Evaluated                                = 0,
	ForcedTrue                               = 1,
	ForcedFalse                              = 2,
};

// Enum StateTreeModule.EStateTreeTransitionSourceType
// NumValues: 0x0004
enum class EStateTreeTransitionSourceType : uint8
{
	Unset                                    = 0,
	Asset                                    = 1,
	ExternalRequest                          = 2,
	Internal                                 = 3,
};

// Enum StateTreeModule.EStateTreeLinkerStatus
// NumValues: 0x0002
enum class EStateTreeLinkerStatus : uint8
{
	Succeeded                                = 0,
	Failed                                   = 1,
};

// Enum StateTreeModule.EStateTreeTraceEventType
// NumValues: 0x0012
enum class EStateTreeTraceEventType : uint8
{
	Unset                                    = 0,
	OnEntering                               = 1,
	OnEntered                                = 2,
	OnExiting                                = 3,
	OnExited                                 = 4,
	Push                                     = 5,
	Pop                                      = 6,
	OnStateSelected                          = 7,
	OnStateCompleted                         = 8,
	OnTicking                                = 9,
	OnTaskCompleted                          = 10,
	OnTicked                                 = 11,
	Passed                                   = 12,
	Failed                                   = 13,
	OnEvaluating                             = 14,
	OnTransition                             = 15,
	OnTreeStarted                            = 16,
	OnTreeStopped                            = 17,
};

// Enum StateTreeModule.EStateTreeBlueprintPropertyCategory
// NumValues: 0x0005
enum class EStateTreeBlueprintPropertyCategory : uint8
{
	NotSet                                   = 0,
	Input                                    = 1,
	Parameter                                = 2,
	Output                                   = 3,
	ContextObject                            = 4,
};

// Enum StateTreeModule.EStateTreeLoopEvents
// NumValues: 0x0002
enum class EStateTreeLoopEvents : uint8
{
	Next                                     = 0,
	Break                                    = 1,
};

// Enum StateTreeModule.EStateTreeBindableStructSource
// NumValues: 0x0007
enum class EStateTreeBindableStructSource : uint8
{
	Context                                  = 0,
	Parameter                                = 1,
	Evaluator                                = 2,
	GlobalTask                               = 3,
	State                                    = 4,
	Task                                     = 5,
	Condition                                = 6,
};

// Enum StateTreeModule.EStateTreePropertyAccessType
// NumValues: 0x0007
enum class EStateTreePropertyAccessType : uint8
{
	Offset                                   = 0,
	Object                                   = 1,
	WeakObject                               = 2,
	SoftObject                               = 3,
	ObjectInstance                           = 4,
	StructInstance                           = 5,
	IndexArray                               = 6,
};

// Enum StateTreeModule.EStateTreePropertyCopyType
// NumValues: 0x0020
enum class EStateTreePropertyCopyType : uint8
{
	None                                     = 0,
	CopyPlain                                = 1,
	CopyComplex                              = 2,
	CopyBool                                 = 3,
	CopyStruct                               = 4,
	CopyObject                               = 5,
	CopyName                                 = 6,
	CopyFixedArray                           = 7,
	StructReference                          = 8,
	PromoteBoolToByte                        = 9,
	PromoteBoolToInt32                       = 10,
	PromoteBoolToUInt32                      = 11,
	PromoteBoolToInt64                       = 12,
	PromoteBoolToFloat                       = 13,
	PromoteBoolToDouble                      = 14,
	PromoteByteToInt32                       = 15,
	PromoteByteToUInt32                      = 16,
	PromoteByteToInt64                       = 17,
	PromoteByteToFloat                       = 18,
	PromoteByteToDouble                      = 19,
	PromoteInt32ToInt64                      = 20,
	PromoteInt32ToFloat                      = 21,
	PromoteInt32ToDouble                     = 22,
	PromoteUInt32ToInt64                     = 23,
	PromoteUInt32ToFloat                     = 24,
	PromoteUInt32ToDouble                    = 25,
	PromoteFloatToInt32                      = 26,
	PromoteFloatToInt64                      = 27,
	PromoteFloatToDouble                     = 28,
	DemoteDoubleToInt32                      = 29,
	DemoteDoubleToInt64                      = 30,
	DemoteDoubleToFloat                      = 31,
};

// Enum StateTreeModule.EStateTreeTransitionType
// NumValues: 0x0007
enum class EStateTreeTransitionType : uint8
{
	None                                     = 0,
	Succeeded                                = 1,
	Failed                                   = 2,
	GotoState                                = 3,
	NextState                                = 4,
	NextSelectableState                      = 5,
	NotSet                                   = 6,
};

// Enum StateTreeModule.EStateTreeConditionOperand
// NumValues: 0x0003
enum class EStateTreeConditionOperand : uint8
{
	Copy                                     = 0,
	And                                      = 1,
	Or                                       = 2,
};

// Enum StateTreeModule.EStateTreeStateType
// NumValues: 0x0004
enum class EStateTreeStateType : uint8
{
	State                                    = 0,
	Group                                    = 1,
	Linked                                   = 2,
	Subtree                                  = 3,
};

// Enum StateTreeModule.EStateTreeStateSelectionBehavior
// NumValues: 0x0004
enum class EStateTreeStateSelectionBehavior : uint8
{
	None                                     = 0,
	TryEnterState                            = 1,
	TrySelectChildrenInOrder                 = 2,
	TryFollowTransitions                     = 3,
};

// Enum StateTreeModule.EStateTreeTransitionTrigger
// NumValues: 0x0007
enum class EStateTreeTransitionTrigger : uint8
{
	None                                     = 0,
	OnStateCompleted                         = 3,
	OnStateSucceeded                         = 1,
	OnStateFailed                            = 2,
	OnTick                                   = 4,
	OnEvent                                  = 8,
	MAX                                      = 9,
};

// Enum StateTreeModule.EStateTreeTransitionPriority
// NumValues: 0x0005
enum class EStateTreeTransitionPriority : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Medium                                   = 2,
	High                                     = 3,
	Critical                                 = 4,
};

// Enum StateTreeModule.EStateTreeSelectionFallback
// NumValues: 0x0002
enum class EStateTreeSelectionFallback : uint8
{
	None                                     = 0,
	NextSelectableSibling                    = 1,
};

// Enum StateTreeModule.EStateTreeExternalDataRequirement
// NumValues: 0x0002
enum class EStateTreeExternalDataRequirement : uint8
{
	Required                                 = 0,
	Optional                                 = 1,
};

// Enum StateTreeModule.EStateTreePropertyUsage
// NumValues: 0x0005
enum class EStateTreePropertyUsage : uint8
{
	Invalid                                  = 0,
	Context                                  = 1,
	Input                                    = 2,
	Parameter                                = 3,
	Output                                   = 4,
};

// ScriptStruct StateTreeModule.StateTreeAnyEnum
// 0x0010 (0x0010 - 0x0000)
struct FStateTreeAnyEnum final
{
public:
	uint32                                        Value;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnum*                                  Enum;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeAnyEnum) == 0x000008, "Wrong alignment on FStateTreeAnyEnum");
static_assert(sizeof(FStateTreeAnyEnum) == 0x000010, "Wrong size on FStateTreeAnyEnum");
static_assert(offsetof(FStateTreeAnyEnum, Value) == 0x000000, "Member 'FStateTreeAnyEnum::Value' has a wrong offset!");
static_assert(offsetof(FStateTreeAnyEnum, Enum) == 0x000008, "Member 'FStateTreeAnyEnum::Enum' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeTransitionSource
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x02) FStateTreeTransitionSource final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeTransitionSource) == 0x000002, "Wrong alignment on FStateTreeTransitionSource");
static_assert(sizeof(FStateTreeTransitionSource) == 0x000008, "Wrong size on FStateTreeTransitionSource");

// ScriptStruct StateTreeModule.StateTreeIndex16
// 0x0002 (0x0002 - 0x0000)
struct FStateTreeIndex16 final
{
public:
	uint16                                        Value;                                             // 0x0000(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FStateTreeIndex16) == 0x000002, "Wrong alignment on FStateTreeIndex16");
static_assert(sizeof(FStateTreeIndex16) == 0x000002, "Wrong size on FStateTreeIndex16");
static_assert(offsetof(FStateTreeIndex16, Value) == 0x000000, "Member 'FStateTreeIndex16::Value' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeExternalDataHandle
// 0x0002 (0x0002 - 0x0000)
struct FStateTreeExternalDataHandle final
{
public:
	struct FStateTreeIndex16                      DataViewIndex;                                     // 0x0000(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeExternalDataHandle) == 0x000002, "Wrong alignment on FStateTreeExternalDataHandle");
static_assert(sizeof(FStateTreeExternalDataHandle) == 0x000002, "Wrong size on FStateTreeExternalDataHandle");
static_assert(offsetof(FStateTreeExternalDataHandle, DataViewIndex) == 0x000000, "Member 'FStateTreeExternalDataHandle::DataViewIndex' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeNodeBase
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FStateTreeNodeBase
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Name;                                              // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      BindingsBatch;                                     // 0x000C(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      DataViewIndex;                                     // 0x000E(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      InstanceIndex;                                     // 0x0010(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bInstanceIsObject : 1;                             // 0x0012(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeNodeBase) == 0x000008, "Wrong alignment on FStateTreeNodeBase");
static_assert(sizeof(FStateTreeNodeBase) == 0x000018, "Wrong size on FStateTreeNodeBase");
static_assert(offsetof(FStateTreeNodeBase, Name) == 0x000008, "Member 'FStateTreeNodeBase::Name' has a wrong offset!");
static_assert(offsetof(FStateTreeNodeBase, BindingsBatch) == 0x00000C, "Member 'FStateTreeNodeBase::BindingsBatch' has a wrong offset!");
static_assert(offsetof(FStateTreeNodeBase, DataViewIndex) == 0x00000E, "Member 'FStateTreeNodeBase::DataViewIndex' has a wrong offset!");
static_assert(offsetof(FStateTreeNodeBase, InstanceIndex) == 0x000010, "Member 'FStateTreeNodeBase::InstanceIndex' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeTaskBase
// 0x0008 (0x0020 - 0x0018)
struct FStateTreeTaskBase : public FStateTreeNodeBase
{
public:
	uint8                                         BitPad_18_0 : 6;                                   // 0x0018(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bTaskEnabled : 1;                                  // 0x0018(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeTaskBase) == 0x000008, "Wrong alignment on FStateTreeTaskBase");
static_assert(sizeof(FStateTreeTaskBase) == 0x000020, "Wrong size on FStateTreeTaskBase");

// ScriptStruct StateTreeModule.StateTreeTaskCommonBase
// 0x0000 (0x0020 - 0x0020)
struct FStateTreeTaskCommonBase : public FStateTreeTaskBase
{
};
static_assert(alignof(FStateTreeTaskCommonBase) == 0x000008, "Wrong alignment on FStateTreeTaskCommonBase");
static_assert(sizeof(FStateTreeTaskCommonBase) == 0x000020, "Wrong size on FStateTreeTaskCommonBase");

// ScriptStruct StateTreeModule.StateTreeExternalDataDesc
// 0x0010 (0x0010 - 0x0000)
struct FStateTreeExternalDataDesc final
{
public:
	class UStruct*                                Struct;                                            // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeExternalDataHandle           Handle;                                            // 0x000C(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	EStateTreeExternalDataRequirement             Requirement;                                       // 0x000E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeExternalDataDesc) == 0x000008, "Wrong alignment on FStateTreeExternalDataDesc");
static_assert(sizeof(FStateTreeExternalDataDesc) == 0x000010, "Wrong size on FStateTreeExternalDataDesc");
static_assert(offsetof(FStateTreeExternalDataDesc, Struct) == 0x000000, "Member 'FStateTreeExternalDataDesc::Struct' has a wrong offset!");
static_assert(offsetof(FStateTreeExternalDataDesc, Name) == 0x000008, "Member 'FStateTreeExternalDataDesc::Name' has a wrong offset!");
static_assert(offsetof(FStateTreeExternalDataDesc, Handle) == 0x00000C, "Member 'FStateTreeExternalDataDesc::Handle' has a wrong offset!");
static_assert(offsetof(FStateTreeExternalDataDesc, Requirement) == 0x00000E, "Member 'FStateTreeExternalDataDesc::Requirement' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeStateHandle
// 0x0002 (0x0002 - 0x0000)
struct FStateTreeStateHandle final
{
public:
	uint16                                        Index;                                             // 0x0000(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeStateHandle) == 0x000002, "Wrong alignment on FStateTreeStateHandle");
static_assert(sizeof(FStateTreeStateHandle) == 0x000002, "Wrong size on FStateTreeStateHandle");
static_assert(offsetof(FStateTreeStateHandle, Index) == 0x000000, "Member 'FStateTreeStateHandle::Index' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeTransitionRequest
// 0x0006 (0x0006 - 0x0000)
struct FStateTreeTransitionRequest final
{
public:
	struct FStateTreeStateHandle                  SourceState;                                       // 0x0000(0x0002)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FStateTreeStateHandle                  TargetState;                                       // 0x0002(0x0002)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	EStateTreeTransitionPriority                  Priority;                                          // 0x0004(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x1];                                        // 0x0005(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeTransitionRequest) == 0x000002, "Wrong alignment on FStateTreeTransitionRequest");
static_assert(sizeof(FStateTreeTransitionRequest) == 0x000006, "Wrong size on FStateTreeTransitionRequest");
static_assert(offsetof(FStateTreeTransitionRequest, SourceState) == 0x000000, "Member 'FStateTreeTransitionRequest::SourceState' has a wrong offset!");
static_assert(offsetof(FStateTreeTransitionRequest, TargetState) == 0x000002, "Member 'FStateTreeTransitionRequest::TargetState' has a wrong offset!");
static_assert(offsetof(FStateTreeTransitionRequest, Priority) == 0x000004, "Member 'FStateTreeTransitionRequest::Priority' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeActiveStates
// 0x0012 (0x0012 - 0x0000)
struct FStateTreeActiveStates final
{
public:
	struct FStateTreeStateHandle                  States[0x8];                                       // 0x0000(0x0002)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         NumStates;                                         // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x1];                                       // 0x0011(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeActiveStates) == 0x000002, "Wrong alignment on FStateTreeActiveStates");
static_assert(sizeof(FStateTreeActiveStates) == 0x000012, "Wrong size on FStateTreeActiveStates");
static_assert(offsetof(FStateTreeActiveStates, States) == 0x000000, "Member 'FStateTreeActiveStates::States' has a wrong offset!");
static_assert(offsetof(FStateTreeActiveStates, NumStates) == 0x000010, "Member 'FStateTreeActiveStates::NumStates' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreePropertySegment
// 0x000C (0x000C - 0x0000)
struct FStateTreePropertySegment final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      ArrayIndex;                                        // 0x0004(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      NextIndex;                                         // 0x0006(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	EStateTreePropertyAccessType                  Type;                                              // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreePropertySegment) == 0x000004, "Wrong alignment on FStateTreePropertySegment");
static_assert(sizeof(FStateTreePropertySegment) == 0x00000C, "Wrong size on FStateTreePropertySegment");
static_assert(offsetof(FStateTreePropertySegment, Name) == 0x000000, "Member 'FStateTreePropertySegment::Name' has a wrong offset!");
static_assert(offsetof(FStateTreePropertySegment, ArrayIndex) == 0x000004, "Member 'FStateTreePropertySegment::ArrayIndex' has a wrong offset!");
static_assert(offsetof(FStateTreePropertySegment, NextIndex) == 0x000006, "Member 'FStateTreePropertySegment::NextIndex' has a wrong offset!");
static_assert(offsetof(FStateTreePropertySegment, Type) == 0x000008, "Member 'FStateTreePropertySegment::Type' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreePropertyBinding
// 0x001C (0x001C - 0x0000)
struct FStateTreePropertyBinding final
{
public:
	struct FStateTreePropertySegment              SourcePath;                                        // 0x0000(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	struct FStateTreePropertySegment              TargetPath;                                        // 0x000C(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      SourceStructIndex;                                 // 0x0018(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	EStateTreePropertyCopyType                    CopyType;                                          // 0x001A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x1];                                       // 0x001B(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreePropertyBinding) == 0x000004, "Wrong alignment on FStateTreePropertyBinding");
static_assert(sizeof(FStateTreePropertyBinding) == 0x00001C, "Wrong size on FStateTreePropertyBinding");
static_assert(offsetof(FStateTreePropertyBinding, SourcePath) == 0x000000, "Member 'FStateTreePropertyBinding::SourcePath' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyBinding, TargetPath) == 0x00000C, "Member 'FStateTreePropertyBinding::TargetPath' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyBinding, SourceStructIndex) == 0x000018, "Member 'FStateTreePropertyBinding::SourceStructIndex' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyBinding, CopyType) == 0x00001A, "Member 'FStateTreePropertyBinding::CopyType' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeTransitionResult
// 0x002E (0x002E - 0x0000)
struct FStateTreeTransitionResult final
{
public:
	struct FStateTreeActiveStates                 CurrentActiveStates;                               // 0x0000(0x0012)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	EStateTreeRunStatus                           CurrentRunStatus;                                  // 0x0012(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStateTreeStateHandle                  SourceState;                                       // 0x0014(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FStateTreeStateHandle                  TargetState;                                       // 0x0016(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FStateTreeActiveStates                 NextActiveStates;                                  // 0x0018(0x0012)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FStateTreeStateHandle                  CurrentState;                                      // 0x002A(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	EStateTreeStateChangeType                     ChangeType;                                        // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStateTreeTransitionPriority                  Priority;                                          // 0x002D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeTransitionResult) == 0x000002, "Wrong alignment on FStateTreeTransitionResult");
static_assert(sizeof(FStateTreeTransitionResult) == 0x00002E, "Wrong size on FStateTreeTransitionResult");
static_assert(offsetof(FStateTreeTransitionResult, CurrentActiveStates) == 0x000000, "Member 'FStateTreeTransitionResult::CurrentActiveStates' has a wrong offset!");
static_assert(offsetof(FStateTreeTransitionResult, CurrentRunStatus) == 0x000012, "Member 'FStateTreeTransitionResult::CurrentRunStatus' has a wrong offset!");
static_assert(offsetof(FStateTreeTransitionResult, SourceState) == 0x000014, "Member 'FStateTreeTransitionResult::SourceState' has a wrong offset!");
static_assert(offsetof(FStateTreeTransitionResult, TargetState) == 0x000016, "Member 'FStateTreeTransitionResult::TargetState' has a wrong offset!");
static_assert(offsetof(FStateTreeTransitionResult, NextActiveStates) == 0x000018, "Member 'FStateTreeTransitionResult::NextActiveStates' has a wrong offset!");
static_assert(offsetof(FStateTreeTransitionResult, CurrentState) == 0x00002A, "Member 'FStateTreeTransitionResult::CurrentState' has a wrong offset!");
static_assert(offsetof(FStateTreeTransitionResult, ChangeType) == 0x00002C, "Member 'FStateTreeTransitionResult::ChangeType' has a wrong offset!");
static_assert(offsetof(FStateTreeTransitionResult, Priority) == 0x00002D, "Member 'FStateTreeTransitionResult::Priority' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeExecutionState
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FStateTreeExecutionState final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeExecutionState) == 0x000008, "Wrong alignment on FStateTreeExecutionState");
static_assert(sizeof(FStateTreeExecutionState) == 0x000030, "Wrong size on FStateTreeExecutionState");

// ScriptStruct StateTreeModule.StateTreeIndex8
// 0x0001 (0x0001 - 0x0000)
struct FStateTreeIndex8 final
{
public:
	uint8                                         Value;                                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FStateTreeIndex8) == 0x000001, "Wrong alignment on FStateTreeIndex8");
static_assert(sizeof(FStateTreeIndex8) == 0x000001, "Wrong size on FStateTreeIndex8");
static_assert(offsetof(FStateTreeIndex8, Value) == 0x000000, "Member 'FStateTreeIndex8::Value' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeConditionBase
// 0x0008 (0x0020 - 0x0018)
struct FStateTreeConditionBase : public FStateTreeNodeBase
{
public:
	EStateTreeConditionOperand                    Operand;                                           // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          DeltaIndent;                                       // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStateTreeConditionEvaluationMode             EvaluationMode;                                    // 0x001A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x5];                                       // 0x001B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeConditionBase) == 0x000008, "Wrong alignment on FStateTreeConditionBase");
static_assert(sizeof(FStateTreeConditionBase) == 0x000020, "Wrong size on FStateTreeConditionBase");
static_assert(offsetof(FStateTreeConditionBase, Operand) == 0x000018, "Member 'FStateTreeConditionBase::Operand' has a wrong offset!");
static_assert(offsetof(FStateTreeConditionBase, DeltaIndent) == 0x000019, "Member 'FStateTreeConditionBase::DeltaIndent' has a wrong offset!");
static_assert(offsetof(FStateTreeConditionBase, EvaluationMode) == 0x00001A, "Member 'FStateTreeConditionBase::EvaluationMode' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeBlueprintConditionWrapper
// 0x0008 (0x0028 - 0x0020)
struct FStateTreeBlueprintConditionWrapper final : public FStateTreeConditionBase
{
public:
	TSubclassOf<class UStateTreeConditionBlueprintBase> ConditionClass;                                    // 0x0020(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeBlueprintConditionWrapper) == 0x000008, "Wrong alignment on FStateTreeBlueprintConditionWrapper");
static_assert(sizeof(FStateTreeBlueprintConditionWrapper) == 0x000028, "Wrong size on FStateTreeBlueprintConditionWrapper");
static_assert(offsetof(FStateTreeBlueprintConditionWrapper, ConditionClass) == 0x000020, "Member 'FStateTreeBlueprintConditionWrapper::ConditionClass' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeEvaluatorBase
// 0x0000 (0x0018 - 0x0018)
struct FStateTreeEvaluatorBase : public FStateTreeNodeBase
{
};
static_assert(alignof(FStateTreeEvaluatorBase) == 0x000008, "Wrong alignment on FStateTreeEvaluatorBase");
static_assert(sizeof(FStateTreeEvaluatorBase) == 0x000018, "Wrong size on FStateTreeEvaluatorBase");

// ScriptStruct StateTreeModule.StateTreeBlueprintEvaluatorWrapper
// 0x0008 (0x0020 - 0x0018)
struct FStateTreeBlueprintEvaluatorWrapper final : public FStateTreeEvaluatorBase
{
public:
	TSubclassOf<class UStateTreeEvaluatorBlueprintBase> EvaluatorClass;                                    // 0x0018(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeBlueprintEvaluatorWrapper) == 0x000008, "Wrong alignment on FStateTreeBlueprintEvaluatorWrapper");
static_assert(sizeof(FStateTreeBlueprintEvaluatorWrapper) == 0x000020, "Wrong size on FStateTreeBlueprintEvaluatorWrapper");
static_assert(offsetof(FStateTreeBlueprintEvaluatorWrapper, EvaluatorClass) == 0x000018, "Member 'FStateTreeBlueprintEvaluatorWrapper::EvaluatorClass' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeBlueprintTaskWrapper
// 0x0008 (0x0028 - 0x0020)
struct FStateTreeBlueprintTaskWrapper final : public FStateTreeTaskBase
{
public:
	TSubclassOf<class UStateTreeTaskBlueprintBase> TaskClass;                                         // 0x0020(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeBlueprintTaskWrapper) == 0x000008, "Wrong alignment on FStateTreeBlueprintTaskWrapper");
static_assert(sizeof(FStateTreeBlueprintTaskWrapper) == 0x000028, "Wrong size on FStateTreeBlueprintTaskWrapper");
static_assert(offsetof(FStateTreeBlueprintTaskWrapper, TaskClass) == 0x000020, "Member 'FStateTreeBlueprintTaskWrapper::TaskClass' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeCompareIntConditionInstanceData
// 0x0008 (0x0008 - 0x0000)
struct FStateTreeCompareIntConditionInstanceData final
{
public:
	int32                                         Left;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Right;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeCompareIntConditionInstanceData) == 0x000004, "Wrong alignment on FStateTreeCompareIntConditionInstanceData");
static_assert(sizeof(FStateTreeCompareIntConditionInstanceData) == 0x000008, "Wrong size on FStateTreeCompareIntConditionInstanceData");
static_assert(offsetof(FStateTreeCompareIntConditionInstanceData, Left) == 0x000000, "Member 'FStateTreeCompareIntConditionInstanceData::Left' has a wrong offset!");
static_assert(offsetof(FStateTreeCompareIntConditionInstanceData, Right) == 0x000004, "Member 'FStateTreeCompareIntConditionInstanceData::Right' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeConditionCommonBase
// 0x0000 (0x0020 - 0x0020)
struct FStateTreeConditionCommonBase : public FStateTreeConditionBase
{
};
static_assert(alignof(FStateTreeConditionCommonBase) == 0x000008, "Wrong alignment on FStateTreeConditionCommonBase");
static_assert(sizeof(FStateTreeConditionCommonBase) == 0x000020, "Wrong size on FStateTreeConditionCommonBase");

// ScriptStruct StateTreeModule.StateTreeCompareIntCondition
// 0x0008 (0x0028 - 0x0020)
struct FStateTreeCompareIntCondition final : public FStateTreeConditionCommonBase
{
public:
	bool                                          bInvert;                                           // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGenericAICheck                               Operator;                                          // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeCompareIntCondition) == 0x000008, "Wrong alignment on FStateTreeCompareIntCondition");
static_assert(sizeof(FStateTreeCompareIntCondition) == 0x000028, "Wrong size on FStateTreeCompareIntCondition");
static_assert(offsetof(FStateTreeCompareIntCondition, bInvert) == 0x000020, "Member 'FStateTreeCompareIntCondition::bInvert' has a wrong offset!");
static_assert(offsetof(FStateTreeCompareIntCondition, Operator) == 0x000021, "Member 'FStateTreeCompareIntCondition::Operator' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeCompareFloatConditionInstanceData
// 0x0010 (0x0010 - 0x0000)
struct FStateTreeCompareFloatConditionInstanceData final
{
public:
	double                                        Left;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Right;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeCompareFloatConditionInstanceData) == 0x000008, "Wrong alignment on FStateTreeCompareFloatConditionInstanceData");
static_assert(sizeof(FStateTreeCompareFloatConditionInstanceData) == 0x000010, "Wrong size on FStateTreeCompareFloatConditionInstanceData");
static_assert(offsetof(FStateTreeCompareFloatConditionInstanceData, Left) == 0x000000, "Member 'FStateTreeCompareFloatConditionInstanceData::Left' has a wrong offset!");
static_assert(offsetof(FStateTreeCompareFloatConditionInstanceData, Right) == 0x000008, "Member 'FStateTreeCompareFloatConditionInstanceData::Right' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeCompareFloatCondition
// 0x0008 (0x0028 - 0x0020)
struct FStateTreeCompareFloatCondition final : public FStateTreeConditionCommonBase
{
public:
	bool                                          bInvert;                                           // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGenericAICheck                               Operator;                                          // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeCompareFloatCondition) == 0x000008, "Wrong alignment on FStateTreeCompareFloatCondition");
static_assert(sizeof(FStateTreeCompareFloatCondition) == 0x000028, "Wrong size on FStateTreeCompareFloatCondition");
static_assert(offsetof(FStateTreeCompareFloatCondition, bInvert) == 0x000020, "Member 'FStateTreeCompareFloatCondition::bInvert' has a wrong offset!");
static_assert(offsetof(FStateTreeCompareFloatCondition, Operator) == 0x000021, "Member 'FStateTreeCompareFloatCondition::Operator' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeCompareBoolConditionInstanceData
// 0x0002 (0x0002 - 0x0000)
struct FStateTreeCompareBoolConditionInstanceData final
{
public:
	bool                                          bLeft;                                             // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRight;                                            // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeCompareBoolConditionInstanceData) == 0x000001, "Wrong alignment on FStateTreeCompareBoolConditionInstanceData");
static_assert(sizeof(FStateTreeCompareBoolConditionInstanceData) == 0x000002, "Wrong size on FStateTreeCompareBoolConditionInstanceData");
static_assert(offsetof(FStateTreeCompareBoolConditionInstanceData, bLeft) == 0x000000, "Member 'FStateTreeCompareBoolConditionInstanceData::bLeft' has a wrong offset!");
static_assert(offsetof(FStateTreeCompareBoolConditionInstanceData, bRight) == 0x000001, "Member 'FStateTreeCompareBoolConditionInstanceData::bRight' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeCompareBoolCondition
// 0x0008 (0x0028 - 0x0020)
struct FStateTreeCompareBoolCondition final : public FStateTreeConditionCommonBase
{
public:
	bool                                          bInvert;                                           // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeCompareBoolCondition) == 0x000008, "Wrong alignment on FStateTreeCompareBoolCondition");
static_assert(sizeof(FStateTreeCompareBoolCondition) == 0x000028, "Wrong size on FStateTreeCompareBoolCondition");
static_assert(offsetof(FStateTreeCompareBoolCondition, bInvert) == 0x000020, "Member 'FStateTreeCompareBoolCondition::bInvert' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeCompareEnumConditionInstanceData
// 0x0020 (0x0020 - 0x0000)
struct FStateTreeCompareEnumConditionInstanceData final
{
public:
	struct FStateTreeAnyEnum                      Left;                                              // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FStateTreeAnyEnum                      Right;                                             // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeCompareEnumConditionInstanceData) == 0x000008, "Wrong alignment on FStateTreeCompareEnumConditionInstanceData");
static_assert(sizeof(FStateTreeCompareEnumConditionInstanceData) == 0x000020, "Wrong size on FStateTreeCompareEnumConditionInstanceData");
static_assert(offsetof(FStateTreeCompareEnumConditionInstanceData, Left) == 0x000000, "Member 'FStateTreeCompareEnumConditionInstanceData::Left' has a wrong offset!");
static_assert(offsetof(FStateTreeCompareEnumConditionInstanceData, Right) == 0x000010, "Member 'FStateTreeCompareEnumConditionInstanceData::Right' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeCompareEnumCondition
// 0x0008 (0x0028 - 0x0020)
struct FStateTreeCompareEnumCondition final : public FStateTreeConditionCommonBase
{
public:
	bool                                          bInvert;                                           // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeCompareEnumCondition) == 0x000008, "Wrong alignment on FStateTreeCompareEnumCondition");
static_assert(sizeof(FStateTreeCompareEnumCondition) == 0x000028, "Wrong size on FStateTreeCompareEnumCondition");
static_assert(offsetof(FStateTreeCompareEnumCondition, bInvert) == 0x000020, "Member 'FStateTreeCompareEnumCondition::bInvert' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeCompareDistanceConditionInstanceData
// 0x0038 (0x0038 - 0x0000)
struct FStateTreeCompareDistanceConditionInstanceData final
{
public:
	struct FVector                                Source;                                            // 0x0000(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Target;                                            // 0x0018(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Distance;                                          // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeCompareDistanceConditionInstanceData) == 0x000008, "Wrong alignment on FStateTreeCompareDistanceConditionInstanceData");
static_assert(sizeof(FStateTreeCompareDistanceConditionInstanceData) == 0x000038, "Wrong size on FStateTreeCompareDistanceConditionInstanceData");
static_assert(offsetof(FStateTreeCompareDistanceConditionInstanceData, Source) == 0x000000, "Member 'FStateTreeCompareDistanceConditionInstanceData::Source' has a wrong offset!");
static_assert(offsetof(FStateTreeCompareDistanceConditionInstanceData, Target) == 0x000018, "Member 'FStateTreeCompareDistanceConditionInstanceData::Target' has a wrong offset!");
static_assert(offsetof(FStateTreeCompareDistanceConditionInstanceData, Distance) == 0x000030, "Member 'FStateTreeCompareDistanceConditionInstanceData::Distance' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeCompareDistanceCondition
// 0x0008 (0x0028 - 0x0020)
struct FStateTreeCompareDistanceCondition final : public FStateTreeConditionCommonBase
{
public:
	bool                                          bInvert;                                           // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGenericAICheck                               Operator;                                          // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeCompareDistanceCondition) == 0x000008, "Wrong alignment on FStateTreeCompareDistanceCondition");
static_assert(sizeof(FStateTreeCompareDistanceCondition) == 0x000028, "Wrong size on FStateTreeCompareDistanceCondition");
static_assert(offsetof(FStateTreeCompareDistanceCondition, bInvert) == 0x000020, "Member 'FStateTreeCompareDistanceCondition::bInvert' has a wrong offset!");
static_assert(offsetof(FStateTreeCompareDistanceCondition, Operator) == 0x000021, "Member 'FStateTreeCompareDistanceCondition::Operator' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeRandomConditionInstanceData
// 0x0004 (0x0004 - 0x0000)
struct FStateTreeRandomConditionInstanceData final
{
public:
	float                                         Threshold;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeRandomConditionInstanceData) == 0x000004, "Wrong alignment on FStateTreeRandomConditionInstanceData");
static_assert(sizeof(FStateTreeRandomConditionInstanceData) == 0x000004, "Wrong size on FStateTreeRandomConditionInstanceData");
static_assert(offsetof(FStateTreeRandomConditionInstanceData, Threshold) == 0x000000, "Member 'FStateTreeRandomConditionInstanceData::Threshold' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeRandomCondition
// 0x0000 (0x0020 - 0x0020)
struct FStateTreeRandomCondition final : public FStateTreeConditionCommonBase
{
};
static_assert(alignof(FStateTreeRandomCondition) == 0x000008, "Wrong alignment on FStateTreeRandomCondition");
static_assert(sizeof(FStateTreeRandomCondition) == 0x000020, "Wrong size on FStateTreeRandomCondition");

// ScriptStruct StateTreeModule.GameplayTagMatchConditionInstanceData
// 0x0028 (0x0028 - 0x0000)
struct FGameplayTagMatchConditionInstanceData final
{
public:
	struct FGameplayTagContainer                  TagContainer;                                      // 0x0000(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTag                           tag;                                               // 0x0020(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayTagMatchConditionInstanceData) == 0x000008, "Wrong alignment on FGameplayTagMatchConditionInstanceData");
static_assert(sizeof(FGameplayTagMatchConditionInstanceData) == 0x000028, "Wrong size on FGameplayTagMatchConditionInstanceData");
static_assert(offsetof(FGameplayTagMatchConditionInstanceData, TagContainer) == 0x000000, "Member 'FGameplayTagMatchConditionInstanceData::TagContainer' has a wrong offset!");
static_assert(offsetof(FGameplayTagMatchConditionInstanceData, tag) == 0x000020, "Member 'FGameplayTagMatchConditionInstanceData::tag' has a wrong offset!");

// ScriptStruct StateTreeModule.GameplayTagMatchCondition
// 0x0008 (0x0028 - 0x0020)
struct FGameplayTagMatchCondition final : public FStateTreeConditionCommonBase
{
public:
	bool                                          bExactMatch;                                       // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvert;                                           // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayTagMatchCondition) == 0x000008, "Wrong alignment on FGameplayTagMatchCondition");
static_assert(sizeof(FGameplayTagMatchCondition) == 0x000028, "Wrong size on FGameplayTagMatchCondition");
static_assert(offsetof(FGameplayTagMatchCondition, bExactMatch) == 0x000020, "Member 'FGameplayTagMatchCondition::bExactMatch' has a wrong offset!");
static_assert(offsetof(FGameplayTagMatchCondition, bInvert) == 0x000021, "Member 'FGameplayTagMatchCondition::bInvert' has a wrong offset!");

// ScriptStruct StateTreeModule.GameplayTagContainerMatchConditionInstanceData
// 0x0040 (0x0040 - 0x0000)
struct FGameplayTagContainerMatchConditionInstanceData final
{
public:
	struct FGameplayTagContainer                  TagContainer;                                      // 0x0000(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  OtherContainer;                                    // 0x0020(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayTagContainerMatchConditionInstanceData) == 0x000008, "Wrong alignment on FGameplayTagContainerMatchConditionInstanceData");
static_assert(sizeof(FGameplayTagContainerMatchConditionInstanceData) == 0x000040, "Wrong size on FGameplayTagContainerMatchConditionInstanceData");
static_assert(offsetof(FGameplayTagContainerMatchConditionInstanceData, TagContainer) == 0x000000, "Member 'FGameplayTagContainerMatchConditionInstanceData::TagContainer' has a wrong offset!");
static_assert(offsetof(FGameplayTagContainerMatchConditionInstanceData, OtherContainer) == 0x000020, "Member 'FGameplayTagContainerMatchConditionInstanceData::OtherContainer' has a wrong offset!");

// ScriptStruct StateTreeModule.GameplayTagContainerMatchCondition
// 0x0008 (0x0028 - 0x0020)
struct FGameplayTagContainerMatchCondition final : public FStateTreeConditionCommonBase
{
public:
	EGameplayContainerMatchType                   MatchType;                                         // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExactMatch;                                       // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvert;                                           // 0x0022(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x5];                                       // 0x0023(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayTagContainerMatchCondition) == 0x000008, "Wrong alignment on FGameplayTagContainerMatchCondition");
static_assert(sizeof(FGameplayTagContainerMatchCondition) == 0x000028, "Wrong size on FGameplayTagContainerMatchCondition");
static_assert(offsetof(FGameplayTagContainerMatchCondition, MatchType) == 0x000020, "Member 'FGameplayTagContainerMatchCondition::MatchType' has a wrong offset!");
static_assert(offsetof(FGameplayTagContainerMatchCondition, bExactMatch) == 0x000021, "Member 'FGameplayTagContainerMatchCondition::bExactMatch' has a wrong offset!");
static_assert(offsetof(FGameplayTagContainerMatchCondition, bInvert) == 0x000022, "Member 'FGameplayTagContainerMatchCondition::bInvert' has a wrong offset!");

// ScriptStruct StateTreeModule.GameplayTagQueryConditionInstanceData
// 0x0020 (0x0020 - 0x0000)
struct FGameplayTagQueryConditionInstanceData final
{
public:
	struct FGameplayTagContainer                  TagContainer;                                      // 0x0000(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayTagQueryConditionInstanceData) == 0x000008, "Wrong alignment on FGameplayTagQueryConditionInstanceData");
static_assert(sizeof(FGameplayTagQueryConditionInstanceData) == 0x000020, "Wrong size on FGameplayTagQueryConditionInstanceData");
static_assert(offsetof(FGameplayTagQueryConditionInstanceData, TagContainer) == 0x000000, "Member 'FGameplayTagQueryConditionInstanceData::TagContainer' has a wrong offset!");

// ScriptStruct StateTreeModule.GameplayTagQueryCondition
// 0x0050 (0x0070 - 0x0020)
struct FGameplayTagQueryCondition final : public FStateTreeConditionCommonBase
{
public:
	struct FGameplayTagQuery                      TagQuery;                                          // 0x0020(0x0048)(Edit, NativeAccessSpecifierPublic)
	bool                                          bInvert;                                           // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayTagQueryCondition) == 0x000008, "Wrong alignment on FGameplayTagQueryCondition");
static_assert(sizeof(FGameplayTagQueryCondition) == 0x000070, "Wrong size on FGameplayTagQueryCondition");
static_assert(offsetof(FGameplayTagQueryCondition, TagQuery) == 0x000020, "Member 'FGameplayTagQueryCondition::TagQuery' has a wrong offset!");
static_assert(offsetof(FGameplayTagQueryCondition, bInvert) == 0x000068, "Member 'FGameplayTagQueryCondition::bInvert' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeObjectIsValidConditionInstanceData
// 0x0008 (0x0008 - 0x0000)
struct FStateTreeObjectIsValidConditionInstanceData final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeObjectIsValidConditionInstanceData) == 0x000008, "Wrong alignment on FStateTreeObjectIsValidConditionInstanceData");
static_assert(sizeof(FStateTreeObjectIsValidConditionInstanceData) == 0x000008, "Wrong size on FStateTreeObjectIsValidConditionInstanceData");
static_assert(offsetof(FStateTreeObjectIsValidConditionInstanceData, Object) == 0x000000, "Member 'FStateTreeObjectIsValidConditionInstanceData::Object' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeObjectIsValidCondition
// 0x0008 (0x0028 - 0x0020)
struct FStateTreeObjectIsValidCondition final : public FStateTreeConditionCommonBase
{
public:
	bool                                          bInvert;                                           // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeObjectIsValidCondition) == 0x000008, "Wrong alignment on FStateTreeObjectIsValidCondition");
static_assert(sizeof(FStateTreeObjectIsValidCondition) == 0x000028, "Wrong size on FStateTreeObjectIsValidCondition");
static_assert(offsetof(FStateTreeObjectIsValidCondition, bInvert) == 0x000020, "Member 'FStateTreeObjectIsValidCondition::bInvert' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeObjectEqualsConditionInstanceData
// 0x0010 (0x0010 - 0x0000)
struct FStateTreeObjectEqualsConditionInstanceData final
{
public:
	class UObject*                                Left;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Right;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeObjectEqualsConditionInstanceData) == 0x000008, "Wrong alignment on FStateTreeObjectEqualsConditionInstanceData");
static_assert(sizeof(FStateTreeObjectEqualsConditionInstanceData) == 0x000010, "Wrong size on FStateTreeObjectEqualsConditionInstanceData");
static_assert(offsetof(FStateTreeObjectEqualsConditionInstanceData, Left) == 0x000000, "Member 'FStateTreeObjectEqualsConditionInstanceData::Left' has a wrong offset!");
static_assert(offsetof(FStateTreeObjectEqualsConditionInstanceData, Right) == 0x000008, "Member 'FStateTreeObjectEqualsConditionInstanceData::Right' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeObjectEqualsCondition
// 0x0008 (0x0028 - 0x0020)
struct FStateTreeObjectEqualsCondition final : public FStateTreeConditionCommonBase
{
public:
	bool                                          bInvert;                                           // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeObjectEqualsCondition) == 0x000008, "Wrong alignment on FStateTreeObjectEqualsCondition");
static_assert(sizeof(FStateTreeObjectEqualsCondition) == 0x000028, "Wrong size on FStateTreeObjectEqualsCondition");
static_assert(offsetof(FStateTreeObjectEqualsCondition, bInvert) == 0x000020, "Member 'FStateTreeObjectEqualsCondition::bInvert' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeObjectIsChildOfClassConditionInstanceData
// 0x0010 (0x0010 - 0x0000)
struct FStateTreeObjectIsChildOfClassConditionInstanceData final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UObject>                    Class;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeObjectIsChildOfClassConditionInstanceData) == 0x000008, "Wrong alignment on FStateTreeObjectIsChildOfClassConditionInstanceData");
static_assert(sizeof(FStateTreeObjectIsChildOfClassConditionInstanceData) == 0x000010, "Wrong size on FStateTreeObjectIsChildOfClassConditionInstanceData");
static_assert(offsetof(FStateTreeObjectIsChildOfClassConditionInstanceData, Object) == 0x000000, "Member 'FStateTreeObjectIsChildOfClassConditionInstanceData::Object' has a wrong offset!");
static_assert(offsetof(FStateTreeObjectIsChildOfClassConditionInstanceData, Class) == 0x000008, "Member 'FStateTreeObjectIsChildOfClassConditionInstanceData::Class' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeObjectIsChildOfClassCondition
// 0x0008 (0x0028 - 0x0020)
struct FStateTreeObjectIsChildOfClassCondition final : public FStateTreeConditionCommonBase
{
public:
	bool                                          bInvert;                                           // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeObjectIsChildOfClassCondition) == 0x000008, "Wrong alignment on FStateTreeObjectIsChildOfClassCondition");
static_assert(sizeof(FStateTreeObjectIsChildOfClassCondition) == 0x000028, "Wrong size on FStateTreeObjectIsChildOfClassCondition");
static_assert(offsetof(FStateTreeObjectIsChildOfClassCondition, bInvert) == 0x000020, "Member 'FStateTreeObjectIsChildOfClassCondition::bInvert' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeEvaluatorCommonBase
// 0x0000 (0x0018 - 0x0018)
struct FStateTreeEvaluatorCommonBase final : public FStateTreeEvaluatorBase
{
};
static_assert(alignof(FStateTreeEvaluatorCommonBase) == 0x000008, "Wrong alignment on FStateTreeEvaluatorCommonBase");
static_assert(sizeof(FStateTreeEvaluatorCommonBase) == 0x000018, "Wrong size on FStateTreeEvaluatorCommonBase");

// ScriptStruct StateTreeModule.StateTreeEvent
// 0x0020 (0x0020 - 0x0000)
struct FStateTreeEvent final
{
public:
	struct FGameplayTag                           tag;                                               // 0x0000(0x0004)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInstancedStruct                       Payload;                                           // 0x0008(0x0010)(Edit, NativeAccessSpecifierPublic)
	class FName                                   Origin;                                            // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeEvent) == 0x000008, "Wrong alignment on FStateTreeEvent");
static_assert(sizeof(FStateTreeEvent) == 0x000020, "Wrong size on FStateTreeEvent");
static_assert(offsetof(FStateTreeEvent, tag) == 0x000000, "Member 'FStateTreeEvent::tag' has a wrong offset!");
static_assert(offsetof(FStateTreeEvent, Payload) == 0x000008, "Member 'FStateTreeEvent::Payload' has a wrong offset!");
static_assert(offsetof(FStateTreeEvent, Origin) == 0x000018, "Member 'FStateTreeEvent::Origin' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeEventQueue
// 0x0010 (0x0010 - 0x0000)
struct FStateTreeEventQueue final
{
public:
	TArray<struct FStateTreeEvent>                Events;                                            // 0x0000(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FStateTreeEventQueue) == 0x000008, "Wrong alignment on FStateTreeEventQueue");
static_assert(sizeof(FStateTreeEventQueue) == 0x000010, "Wrong size on FStateTreeEventQueue");
static_assert(offsetof(FStateTreeEventQueue, Events) == 0x000000, "Member 'FStateTreeEventQueue::Events' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeInstanceStorage
// 0x0040 (0x0040 - 0x0000)
struct FStateTreeInstanceStorage final
{
public:
	struct FInstancedStructContainer              InstanceStructs;                                   // 0x0000(0x0010)(Protected, NativeAccessSpecifierProtected)
	TArray<class UObject*>                        InstanceObjects;                                   // 0x0010(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FStateTreeEventQueue                   EventQueue;                                        // 0x0020(0x0010)(Protected, NativeAccessSpecifierProtected)
	TArray<struct FStateTreeTransitionRequest>    TransitionRequests;                                // 0x0030(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FStateTreeInstanceStorage) == 0x000008, "Wrong alignment on FStateTreeInstanceStorage");
static_assert(sizeof(FStateTreeInstanceStorage) == 0x000040, "Wrong size on FStateTreeInstanceStorage");
static_assert(offsetof(FStateTreeInstanceStorage, InstanceStructs) == 0x000000, "Member 'FStateTreeInstanceStorage::InstanceStructs' has a wrong offset!");
static_assert(offsetof(FStateTreeInstanceStorage, InstanceObjects) == 0x000010, "Member 'FStateTreeInstanceStorage::InstanceObjects' has a wrong offset!");
static_assert(offsetof(FStateTreeInstanceStorage, EventQueue) == 0x000020, "Member 'FStateTreeInstanceStorage::EventQueue' has a wrong offset!");
static_assert(offsetof(FStateTreeInstanceStorage, TransitionRequests) == 0x000030, "Member 'FStateTreeInstanceStorage::TransitionRequests' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeInstanceData
// 0x0010 (0x0010 - 0x0000)
struct FStateTreeInstanceData final
{
public:
	struct FInstancedStruct                       InstanceStorage;                                   // 0x0000(0x0010)(Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FStateTreeInstanceData) == 0x000008, "Wrong alignment on FStateTreeInstanceData");
static_assert(sizeof(FStateTreeInstanceData) == 0x000010, "Wrong size on FStateTreeInstanceData");
static_assert(offsetof(FStateTreeInstanceData, InstanceStorage) == 0x000000, "Member 'FStateTreeInstanceData::InstanceStorage' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeBindableStructDesc
// 0x0010 (0x0010 - 0x0000)
struct FStateTreeBindableStructDesc final
{
public:
	class UStruct*                                Struct;                                            // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStateTreeBindableStructSource                DataSource;                                        // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeBindableStructDesc) == 0x000008, "Wrong alignment on FStateTreeBindableStructDesc");
static_assert(sizeof(FStateTreeBindableStructDesc) == 0x000010, "Wrong size on FStateTreeBindableStructDesc");
static_assert(offsetof(FStateTreeBindableStructDesc, Struct) == 0x000000, "Member 'FStateTreeBindableStructDesc::Struct' has a wrong offset!");
static_assert(offsetof(FStateTreeBindableStructDesc, Name) == 0x000008, "Member 'FStateTreeBindableStructDesc::Name' has a wrong offset!");
static_assert(offsetof(FStateTreeBindableStructDesc, DataSource) == 0x00000C, "Member 'FStateTreeBindableStructDesc::DataSource' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreePropertyPathSegment
// 0x0010 (0x0010 - 0x0000)
struct FStateTreePropertyPathSegment final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ArrayIndex;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStruct*                                InstanceStruct;                                    // 0x0008(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FStateTreePropertyPathSegment) == 0x000008, "Wrong alignment on FStateTreePropertyPathSegment");
static_assert(sizeof(FStateTreePropertyPathSegment) == 0x000010, "Wrong size on FStateTreePropertyPathSegment");
static_assert(offsetof(FStateTreePropertyPathSegment, Name) == 0x000000, "Member 'FStateTreePropertyPathSegment::Name' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyPathSegment, ArrayIndex) == 0x000004, "Member 'FStateTreePropertyPathSegment::ArrayIndex' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyPathSegment, InstanceStruct) == 0x000008, "Member 'FStateTreePropertyPathSegment::InstanceStruct' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreePropertyPath
// 0x0010 (0x0010 - 0x0000)
struct FStateTreePropertyPath final
{
public:
	TArray<struct FStateTreePropertyPathSegment>  Segments;                                          // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FStateTreePropertyPath) == 0x000008, "Wrong alignment on FStateTreePropertyPath");
static_assert(sizeof(FStateTreePropertyPath) == 0x000010, "Wrong size on FStateTreePropertyPath");
static_assert(offsetof(FStateTreePropertyPath, Segments) == 0x000000, "Member 'FStateTreePropertyPath::Segments' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeEditorPropertyPath
// 0x0020 (0x0020 - 0x0000)
struct FStateTreeEditorPropertyPath final
{
public:
	struct FGuid                                  StructID;                                          // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Path;                                              // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeEditorPropertyPath) == 0x000008, "Wrong alignment on FStateTreeEditorPropertyPath");
static_assert(sizeof(FStateTreeEditorPropertyPath) == 0x000020, "Wrong size on FStateTreeEditorPropertyPath");
static_assert(offsetof(FStateTreeEditorPropertyPath, StructID) == 0x000000, "Member 'FStateTreeEditorPropertyPath::StructID' has a wrong offset!");
static_assert(offsetof(FStateTreeEditorPropertyPath, Path) == 0x000010, "Member 'FStateTreeEditorPropertyPath::Path' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreePropertyPathBinding
// 0x0028 (0x0028 - 0x0000)
struct FStateTreePropertyPathBinding final
{
public:
	struct FStateTreePropertyPath                 SourcePropertyPath;                                // 0x0000(0x0010)(NativeAccessSpecifierPrivate)
	struct FStateTreePropertyPath                 TargetPropertyPath;                                // 0x0010(0x0010)(NativeAccessSpecifierPrivate)
	struct FStateTreeIndex16                      CompiledSourceStructIndex;                         // 0x0020(0x0002)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreePropertyPathBinding) == 0x000008, "Wrong alignment on FStateTreePropertyPathBinding");
static_assert(sizeof(FStateTreePropertyPathBinding) == 0x000028, "Wrong size on FStateTreePropertyPathBinding");
static_assert(offsetof(FStateTreePropertyPathBinding, SourcePropertyPath) == 0x000000, "Member 'FStateTreePropertyPathBinding::SourcePropertyPath' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyPathBinding, TargetPropertyPath) == 0x000010, "Member 'FStateTreePropertyPathBinding::TargetPropertyPath' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyPathBinding, CompiledSourceStructIndex) == 0x000020, "Member 'FStateTreePropertyPathBinding::CompiledSourceStructIndex' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreePropertyIndirection
// 0x0018 (0x0018 - 0x0000)
struct FStateTreePropertyIndirection final
{
public:
	struct FStateTreeIndex16                      ArrayIndex;                                        // 0x0000(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	uint16                                        Offset;                                            // 0x0002(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      NextIndex;                                         // 0x0004(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	EStateTreePropertyAccessType                  Type;                                              // 0x0006(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7[0x1];                                        // 0x0007(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UStruct*                                InstanceStruct;                                    // 0x0008(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreePropertyIndirection) == 0x000008, "Wrong alignment on FStateTreePropertyIndirection");
static_assert(sizeof(FStateTreePropertyIndirection) == 0x000018, "Wrong size on FStateTreePropertyIndirection");
static_assert(offsetof(FStateTreePropertyIndirection, ArrayIndex) == 0x000000, "Member 'FStateTreePropertyIndirection::ArrayIndex' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyIndirection, Offset) == 0x000002, "Member 'FStateTreePropertyIndirection::Offset' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyIndirection, NextIndex) == 0x000004, "Member 'FStateTreePropertyIndirection::NextIndex' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyIndirection, Type) == 0x000006, "Member 'FStateTreePropertyIndirection::Type' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyIndirection, InstanceStruct) == 0x000008, "Member 'FStateTreePropertyIndirection::InstanceStruct' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreePropertyCopy
// 0x0048 (0x0048 - 0x0000)
struct FStateTreePropertyCopy final
{
public:
	struct FStateTreePropertyIndirection          SourceIndirection;                                 // 0x0000(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	struct FStateTreePropertyIndirection          TargetIndirection;                                 // 0x0018(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CopySize;                                          // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      SourceStructIndex;                                 // 0x0044(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	EStateTreePropertyCopyType                    Type;                                              // 0x0046(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47[0x1];                                       // 0x0047(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreePropertyCopy) == 0x000008, "Wrong alignment on FStateTreePropertyCopy");
static_assert(sizeof(FStateTreePropertyCopy) == 0x000048, "Wrong size on FStateTreePropertyCopy");
static_assert(offsetof(FStateTreePropertyCopy, SourceIndirection) == 0x000000, "Member 'FStateTreePropertyCopy::SourceIndirection' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyCopy, TargetIndirection) == 0x000018, "Member 'FStateTreePropertyCopy::TargetIndirection' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyCopy, CopySize) == 0x000040, "Member 'FStateTreePropertyCopy::CopySize' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyCopy, SourceStructIndex) == 0x000044, "Member 'FStateTreePropertyCopy::SourceStructIndex' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyCopy, Type) == 0x000046, "Member 'FStateTreePropertyCopy::Type' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreePropertyCopyBatch
// 0x0018 (0x0018 - 0x0000)
struct FStateTreePropertyCopyBatch final
{
public:
	struct FStateTreeBindableStructDesc           TargetStruct;                                      // 0x0000(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	uint16                                        BindingsBegin;                                     // 0x0010(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        BindingsEnd;                                       // 0x0012(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreePropertyCopyBatch) == 0x000008, "Wrong alignment on FStateTreePropertyCopyBatch");
static_assert(sizeof(FStateTreePropertyCopyBatch) == 0x000018, "Wrong size on FStateTreePropertyCopyBatch");
static_assert(offsetof(FStateTreePropertyCopyBatch, TargetStruct) == 0x000000, "Member 'FStateTreePropertyCopyBatch::TargetStruct' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyCopyBatch, BindingsBegin) == 0x000010, "Member 'FStateTreePropertyCopyBatch::BindingsBegin' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyCopyBatch, BindingsEnd) == 0x000012, "Member 'FStateTreePropertyCopyBatch::BindingsEnd' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreePropertyBindings
// 0x0058 (0x0058 - 0x0000)
struct FStateTreePropertyBindings final
{
public:
	TArray<struct FStateTreeBindableStructDesc>   SourceStructs;                                     // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FStateTreePropertyCopyBatch>    CopyBatches;                                       // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FStateTreePropertyPathBinding>  PropertyPathBindings;                              // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FStateTreePropertyCopy>         PropertyCopies;                                    // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FStateTreePropertyIndirection>  PropertyIndirections;                              // 0x0040(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreePropertyBindings) == 0x000008, "Wrong alignment on FStateTreePropertyBindings");
static_assert(sizeof(FStateTreePropertyBindings) == 0x000058, "Wrong size on FStateTreePropertyBindings");
static_assert(offsetof(FStateTreePropertyBindings, SourceStructs) == 0x000000, "Member 'FStateTreePropertyBindings::SourceStructs' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyBindings, CopyBatches) == 0x000010, "Member 'FStateTreePropertyBindings::CopyBatches' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyBindings, PropertyPathBindings) == 0x000020, "Member 'FStateTreePropertyBindings::PropertyPathBindings' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyBindings, PropertyCopies) == 0x000030, "Member 'FStateTreePropertyBindings::PropertyCopies' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyBindings, PropertyIndirections) == 0x000040, "Member 'FStateTreePropertyBindings::PropertyIndirections' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeReference
// 0x0018 (0x0018 - 0x0000)
struct FStateTreeReference final
{
public:
	class UStateTree*                             StateTree;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FInstancedPropertyBag                  Parameters;                                        // 0x0008(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FStateTreeReference) == 0x000008, "Wrong alignment on FStateTreeReference");
static_assert(sizeof(FStateTreeReference) == 0x000018, "Wrong size on FStateTreeReference");
static_assert(offsetof(FStateTreeReference, StateTree) == 0x000000, "Member 'FStateTreeReference::StateTree' has a wrong offset!");
static_assert(offsetof(FStateTreeReference, Parameters) == 0x000008, "Member 'FStateTreeReference::Parameters' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeRandomTimeDuration
// 0x0004 (0x0004 - 0x0000)
struct FStateTreeRandomTimeDuration final
{
public:
	uint16                                        duration;                                          // 0x0000(0x0002)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint16                                        RandomVariance;                                    // 0x0002(0x0002)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FStateTreeRandomTimeDuration) == 0x000002, "Wrong alignment on FStateTreeRandomTimeDuration");
static_assert(sizeof(FStateTreeRandomTimeDuration) == 0x000004, "Wrong size on FStateTreeRandomTimeDuration");
static_assert(offsetof(FStateTreeRandomTimeDuration, duration) == 0x000000, "Member 'FStateTreeRandomTimeDuration::duration' has a wrong offset!");
static_assert(offsetof(FStateTreeRandomTimeDuration, RandomVariance) == 0x000002, "Member 'FStateTreeRandomTimeDuration::RandomVariance' has a wrong offset!");

// ScriptStruct StateTreeModule.CompactStateTransition
// 0x0014 (0x0014 - 0x0000)
struct FCompactStateTransition final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        ConditionsBegin;                                   // 0x0004(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeStateHandle                  State;                                             // 0x0006(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	struct FStateTreeRandomTimeDuration           Delay;                                             // 0x0008(0x0004)(NoDestructor, NativeAccessSpecifierPublic)
	EStateTreeTransitionTrigger                   Trigger;                                           // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStateTreeTransitionPriority                  Priority;                                          // 0x000D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStateTreeSelectionFallback                   Fallback;                                          // 0x000E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ConditionsNum;                                     // 0x000F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bTransitionEnabled : 1;                            // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCompactStateTransition) == 0x000004, "Wrong alignment on FCompactStateTransition");
static_assert(sizeof(FCompactStateTransition) == 0x000014, "Wrong size on FCompactStateTransition");
static_assert(offsetof(FCompactStateTransition, EventTag) == 0x000000, "Member 'FCompactStateTransition::EventTag' has a wrong offset!");
static_assert(offsetof(FCompactStateTransition, ConditionsBegin) == 0x000004, "Member 'FCompactStateTransition::ConditionsBegin' has a wrong offset!");
static_assert(offsetof(FCompactStateTransition, State) == 0x000006, "Member 'FCompactStateTransition::State' has a wrong offset!");
static_assert(offsetof(FCompactStateTransition, Delay) == 0x000008, "Member 'FCompactStateTransition::Delay' has a wrong offset!");
static_assert(offsetof(FCompactStateTransition, Trigger) == 0x00000C, "Member 'FCompactStateTransition::Trigger' has a wrong offset!");
static_assert(offsetof(FCompactStateTransition, Priority) == 0x00000D, "Member 'FCompactStateTransition::Priority' has a wrong offset!");
static_assert(offsetof(FCompactStateTransition, Fallback) == 0x00000E, "Member 'FCompactStateTransition::Fallback' has a wrong offset!");
static_assert(offsetof(FCompactStateTransition, ConditionsNum) == 0x00000F, "Member 'FCompactStateTransition::ConditionsNum' has a wrong offset!");

// ScriptStruct StateTreeModule.CompactStateTreeState
// 0x0020 (0x0020 - 0x0000)
struct FCompactStateTreeState final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeStateHandle                  LinkedState;                                       // 0x0004(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	struct FStateTreeStateHandle                  Parent;                                            // 0x0006(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	uint16                                        ChildrenBegin;                                     // 0x0008(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        ChildrenEnd;                                       // 0x000A(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        EnterConditionsBegin;                              // 0x000C(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        TransitionsBegin;                                  // 0x000E(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        TasksBegin;                                        // 0x0010(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      ParameterInstanceIndex;                            // 0x0012(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      ParameterDataViewIndex;                            // 0x0014(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         EnterConditionsNum;                                // 0x0016(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TransitionsNum;                                    // 0x0017(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TasksNum;                                          // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TaskInstanceStructNum;                             // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TaskInstanceObjectNum;                             // 0x001A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStateTreeStateType                           Type;                                              // 0x001B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStateTreeStateSelectionBehavior              SelectionBehavior;                                 // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHasTransitionTasks : 1;                           // 0x001D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnabled : 1;                                      // 0x001D(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCompactStateTreeState) == 0x000004, "Wrong alignment on FCompactStateTreeState");
static_assert(sizeof(FCompactStateTreeState) == 0x000020, "Wrong size on FCompactStateTreeState");
static_assert(offsetof(FCompactStateTreeState, Name) == 0x000000, "Member 'FCompactStateTreeState::Name' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, LinkedState) == 0x000004, "Member 'FCompactStateTreeState::LinkedState' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, Parent) == 0x000006, "Member 'FCompactStateTreeState::Parent' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, ChildrenBegin) == 0x000008, "Member 'FCompactStateTreeState::ChildrenBegin' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, ChildrenEnd) == 0x00000A, "Member 'FCompactStateTreeState::ChildrenEnd' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, EnterConditionsBegin) == 0x00000C, "Member 'FCompactStateTreeState::EnterConditionsBegin' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, TransitionsBegin) == 0x00000E, "Member 'FCompactStateTreeState::TransitionsBegin' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, TasksBegin) == 0x000010, "Member 'FCompactStateTreeState::TasksBegin' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, ParameterInstanceIndex) == 0x000012, "Member 'FCompactStateTreeState::ParameterInstanceIndex' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, ParameterDataViewIndex) == 0x000014, "Member 'FCompactStateTreeState::ParameterDataViewIndex' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, EnterConditionsNum) == 0x000016, "Member 'FCompactStateTreeState::EnterConditionsNum' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, TransitionsNum) == 0x000017, "Member 'FCompactStateTreeState::TransitionsNum' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, TasksNum) == 0x000018, "Member 'FCompactStateTreeState::TasksNum' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, TaskInstanceStructNum) == 0x000019, "Member 'FCompactStateTreeState::TaskInstanceStructNum' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, TaskInstanceObjectNum) == 0x00001A, "Member 'FCompactStateTreeState::TaskInstanceObjectNum' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, Type) == 0x00001B, "Member 'FCompactStateTreeState::Type' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeState, SelectionBehavior) == 0x00001C, "Member 'FCompactStateTreeState::SelectionBehavior' has a wrong offset!");

// ScriptStruct StateTreeModule.CompactStateTreeParameters
// 0x0018 (0x0018 - 0x0000)
struct FCompactStateTreeParameters final
{
public:
	struct FStateTreeIndex16                      BindingsBatch;                                     // 0x0000(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInstancedPropertyBag                  Parameters;                                        // 0x0008(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCompactStateTreeParameters) == 0x000008, "Wrong alignment on FCompactStateTreeParameters");
static_assert(sizeof(FCompactStateTreeParameters) == 0x000018, "Wrong size on FCompactStateTreeParameters");
static_assert(offsetof(FCompactStateTreeParameters, BindingsBatch) == 0x000000, "Member 'FCompactStateTreeParameters::BindingsBatch' has a wrong offset!");
static_assert(offsetof(FCompactStateTreeParameters, Parameters) == 0x000008, "Member 'FCompactStateTreeParameters::Parameters' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeStateIdToHandle
// 0x0014 (0x0014 - 0x0000)
struct FStateTreeStateIdToHandle final
{
public:
	struct FGuid                                  ID;                                                // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeStateHandle                  Handle;                                            // 0x0010(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeStateIdToHandle) == 0x000004, "Wrong alignment on FStateTreeStateIdToHandle");
static_assert(sizeof(FStateTreeStateIdToHandle) == 0x000014, "Wrong size on FStateTreeStateIdToHandle");
static_assert(offsetof(FStateTreeStateIdToHandle, ID) == 0x000000, "Member 'FStateTreeStateIdToHandle::ID' has a wrong offset!");
static_assert(offsetof(FStateTreeStateIdToHandle, Handle) == 0x000010, "Member 'FStateTreeStateIdToHandle::Handle' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeNodeIdToIndex
// 0x0014 (0x0014 - 0x0000)
struct FStateTreeNodeIdToIndex final
{
public:
	struct FGuid                                  ID;                                                // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      Index;                                             // 0x0010(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeNodeIdToIndex) == 0x000004, "Wrong alignment on FStateTreeNodeIdToIndex");
static_assert(sizeof(FStateTreeNodeIdToIndex) == 0x000014, "Wrong size on FStateTreeNodeIdToIndex");
static_assert(offsetof(FStateTreeNodeIdToIndex, ID) == 0x000000, "Member 'FStateTreeNodeIdToIndex::ID' has a wrong offset!");
static_assert(offsetof(FStateTreeNodeIdToIndex, Index) == 0x000010, "Member 'FStateTreeNodeIdToIndex::Index' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeTransitionIdToIndex
// 0x0014 (0x0014 - 0x0000)
struct FStateTreeTransitionIdToIndex final
{
public:
	struct FGuid                                  ID;                                                // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeIndex16                      Index;                                             // 0x0010(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeTransitionIdToIndex) == 0x000004, "Wrong alignment on FStateTreeTransitionIdToIndex");
static_assert(sizeof(FStateTreeTransitionIdToIndex) == 0x000014, "Wrong size on FStateTreeTransitionIdToIndex");
static_assert(offsetof(FStateTreeTransitionIdToIndex, ID) == 0x000000, "Member 'FStateTreeTransitionIdToIndex::ID' has a wrong offset!");
static_assert(offsetof(FStateTreeTransitionIdToIndex, Index) == 0x000010, "Member 'FStateTreeTransitionIdToIndex::Index' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeStructRef
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FStateTreeStructRef final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeStructRef) == 0x000008, "Wrong alignment on FStateTreeStructRef");
static_assert(sizeof(FStateTreeStructRef) == 0x000010, "Wrong size on FStateTreeStructRef");

// ScriptStruct StateTreeModule.StateTreeStateLink
// 0x0002 (0x0002 - 0x0000)
struct FStateTreeStateLink final
{
public:
	struct FStateTreeStateHandle                  StateHandle;                                       // 0x0000(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeStateLink) == 0x000002, "Wrong alignment on FStateTreeStateLink");
static_assert(sizeof(FStateTreeStateLink) == 0x000002, "Wrong size on FStateTreeStateLink");
static_assert(offsetof(FStateTreeStateLink, StateHandle) == 0x000000, "Member 'FStateTreeStateLink::StateHandle' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeDebugTextTaskInstanceData
// 0x0008 (0x0008 - 0x0000)
struct FStateTreeDebugTextTaskInstanceData final
{
public:
	class AActor*                                 ReferenceActor;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeDebugTextTaskInstanceData) == 0x000008, "Wrong alignment on FStateTreeDebugTextTaskInstanceData");
static_assert(sizeof(FStateTreeDebugTextTaskInstanceData) == 0x000008, "Wrong size on FStateTreeDebugTextTaskInstanceData");
static_assert(offsetof(FStateTreeDebugTextTaskInstanceData, ReferenceActor) == 0x000000, "Member 'FStateTreeDebugTextTaskInstanceData::ReferenceActor' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeDebugTextTask
// 0x0038 (0x0058 - 0x0020)
struct FStateTreeDebugTextTask final : public FStateTreeTaskCommonBase
{
public:
	class FString                                 Text;                                              // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 TextColor;                                         // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FontScale;                                         // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x0038(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeDebugTextTask) == 0x000008, "Wrong alignment on FStateTreeDebugTextTask");
static_assert(sizeof(FStateTreeDebugTextTask) == 0x000058, "Wrong size on FStateTreeDebugTextTask");
static_assert(offsetof(FStateTreeDebugTextTask, Text) == 0x000020, "Member 'FStateTreeDebugTextTask::Text' has a wrong offset!");
static_assert(offsetof(FStateTreeDebugTextTask, TextColor) == 0x000030, "Member 'FStateTreeDebugTextTask::TextColor' has a wrong offset!");
static_assert(offsetof(FStateTreeDebugTextTask, FontScale) == 0x000034, "Member 'FStateTreeDebugTextTask::FontScale' has a wrong offset!");
static_assert(offsetof(FStateTreeDebugTextTask, Offset) == 0x000038, "Member 'FStateTreeDebugTextTask::Offset' has a wrong offset!");
static_assert(offsetof(FStateTreeDebugTextTask, bEnabled) == 0x000050, "Member 'FStateTreeDebugTextTask::bEnabled' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeDelayTaskInstanceData
// 0x0010 (0x0010 - 0x0000)
struct FStateTreeDelayTaskInstanceData final
{
public:
	float                                         duration;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomDeviation;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRunForever;                                       // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeDelayTaskInstanceData) == 0x000004, "Wrong alignment on FStateTreeDelayTaskInstanceData");
static_assert(sizeof(FStateTreeDelayTaskInstanceData) == 0x000010, "Wrong size on FStateTreeDelayTaskInstanceData");
static_assert(offsetof(FStateTreeDelayTaskInstanceData, duration) == 0x000000, "Member 'FStateTreeDelayTaskInstanceData::duration' has a wrong offset!");
static_assert(offsetof(FStateTreeDelayTaskInstanceData, RandomDeviation) == 0x000004, "Member 'FStateTreeDelayTaskInstanceData::RandomDeviation' has a wrong offset!");
static_assert(offsetof(FStateTreeDelayTaskInstanceData, bRunForever) == 0x000008, "Member 'FStateTreeDelayTaskInstanceData::bRunForever' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeDelayTask
// 0x0000 (0x0020 - 0x0020)
struct FStateTreeDelayTask final : public FStateTreeTaskCommonBase
{
};
static_assert(alignof(FStateTreeDelayTask) == 0x000008, "Wrong alignment on FStateTreeDelayTask");
static_assert(sizeof(FStateTreeDelayTask) == 0x000020, "Wrong size on FStateTreeDelayTask");

}

