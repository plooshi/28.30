#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Tweening

#include "Basic.hpp"

#include "Tweening_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class Tweening.TweenSplineInfo
// 0x0010 (0x0038 - 0x0028)
class UTweenSplineInfo final : public UObject
{
public:
	TWeakObjectPtr<class USplineComponent>        Spline;                                            // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETweenSplineAlignmentOption                   Alignment;                                         // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnorePitch;                                      // 0x0031(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreYaw;                                        // 0x0032(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreRoll;                                       // 0x0033(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TweenSplineInfo">();
	}
	static class UTweenSplineInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTweenSplineInfo>();
	}
};
static_assert(alignof(UTweenSplineInfo) == 0x000008, "Wrong alignment on UTweenSplineInfo");
static_assert(sizeof(UTweenSplineInfo) == 0x000038, "Wrong size on UTweenSplineInfo");
static_assert(offsetof(UTweenSplineInfo, Spline) == 0x000028, "Member 'UTweenSplineInfo::Spline' has a wrong offset!");
static_assert(offsetof(UTweenSplineInfo, Alignment) == 0x000030, "Member 'UTweenSplineInfo::Alignment' has a wrong offset!");
static_assert(offsetof(UTweenSplineInfo, bIgnorePitch) == 0x000031, "Member 'UTweenSplineInfo::bIgnorePitch' has a wrong offset!");
static_assert(offsetof(UTweenSplineInfo, bIgnoreYaw) == 0x000032, "Member 'UTweenSplineInfo::bIgnoreYaw' has a wrong offset!");
static_assert(offsetof(UTweenSplineInfo, bIgnoreRoll) == 0x000033, "Member 'UTweenSplineInfo::bIgnoreRoll' has a wrong offset!");

// Class Tweening.ActorTweening
// 0x0000 (0x0028 - 0x0028)
class UActorTweening final : public UBlueprintFunctionLibrary
{
public:
	static void BP_TransformAlongSplineTo(int32* OutTweenId, class UObject* ContextObject, class AActor*& Target, class USplineComponent* Spline, ETweenSplineAlignmentOption Alignment, bool bIgnorePitch, bool bIgnoreYaw, bool bIgnoreRoll, const struct FTweenOptionalFloat& FromOptions, float ToValue, bool bIsRelative, float duration, const struct FTweenDelayOptions& DelayOptions, ETweenBuiltInEasing EasingFunction, class UCurveFloat* EasingCurve, const struct FTweenLoopOptions& LoopOptions, bool bAutoPlay, bool bAutoKill);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorTweening">();
	}
	static class UActorTweening* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorTweening>();
	}
};
static_assert(alignof(UActorTweening) == 0x000008, "Wrong alignment on UActorTweening");
static_assert(sizeof(UActorTweening) == 0x000028, "Wrong size on UActorTweening");

// Class Tweening.TweenMaterialParameterInfo
// 0x0008 (0x0030 - 0x0028)
class UTweenMaterialParameterInfo final : public UObject
{
public:
	class FName                                   ParameterName;                                     // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TweenMaterialParameterInfo">();
	}
	static class UTweenMaterialParameterInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTweenMaterialParameterInfo>();
	}
};
static_assert(alignof(UTweenMaterialParameterInfo) == 0x000008, "Wrong alignment on UTweenMaterialParameterInfo");
static_assert(sizeof(UTweenMaterialParameterInfo) == 0x000030, "Wrong size on UTweenMaterialParameterInfo");
static_assert(offsetof(UTweenMaterialParameterInfo, ParameterName) == 0x000028, "Member 'UTweenMaterialParameterInfo::ParameterName' has a wrong offset!");

// Class Tweening.MaterialTweening
// 0x0000 (0x0028 - 0x0028)
class UMaterialTweening final : public UBlueprintFunctionLibrary
{
public:
	static void BP_ColorParamTo(int32* OutTweenId, class UObject* ContextObject, class UMaterialInstanceDynamic*& Target, class FName ParameterName, const struct FTweenOptionalLinearColor& FromOptions, const struct FLinearColor& ToValue, float duration, const struct FTweenDelayOptions& DelayOptions, ETweenBuiltInEasing EasingFunction, class UCurveFloat* EasingCurve, const struct FTweenLoopOptions& LoopOptions, bool bAutoPlay, bool bAutoKill);
	static void BP_ScalarParamTo(int32* OutTweenId, class UObject* ContextObject, class UMaterialInstanceDynamic*& Target, class FName ParameterName, const struct FTweenOptionalFloat& FromOptions, float ToValue, bool bIsRelative, float duration, const struct FTweenDelayOptions& DelayOptions, ETweenBuiltInEasing EasingFunction, class UCurveFloat* EasingCurve, const struct FTweenLoopOptions& LoopOptions, bool bAutoPlay, bool bAutoKill);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialTweening">();
	}
	static class UMaterialTweening* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialTweening>();
	}
};
static_assert(alignof(UMaterialTweening) == 0x000008, "Wrong alignment on UMaterialTweening");
static_assert(sizeof(UMaterialTweening) == 0x000028, "Wrong size on UMaterialTweening");

// Class Tweening.TweenManager
// 0x00B8 (0x00E8 - 0x0030)
class UTweenManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class UObject*>                   TweenContexts;                                     // 0x0038(0x0050)(Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_88[0x60];                                      // 0x0088(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool HasTween(int32 InTweenId);
	bool KillTween(int32 InTweenId);
	void KillTweens(const TArray<int32>& InTweenIds);
	bool PlayTween(int32 InTweenId, ETweenPlayDirection InPlayDirection);
	void PlayTweens(const TArray<int32>& InTweenIds, ETweenPlayDirection InPlayDirection);
	bool PlayTweenWithLooping(int32 InTweenId, ETweenLoopType InLoopType, int32 InLoopCount, ETweenPlayDirection InPlayDirection);
	bool ResetTween(int32 InTweenId, ETweenResetDestination InDestination);
	void ResetTweens(const TArray<int32>& InTweenIds, ETweenResetDestination InDestination);
	bool StopTween(int32 InTweenId);
	void StopTweens(const TArray<int32>& InTweenIds);

	bool SetTweenTiming(int32 InTweenId, float InDuration, float InDelayAtBeginning, float InDelayAtEnd) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TweenManager">();
	}
	static class UTweenManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTweenManager>();
	}
};
static_assert(alignof(UTweenManager) == 0x000008, "Wrong alignment on UTweenManager");
static_assert(sizeof(UTweenManager) == 0x0000E8, "Wrong size on UTweenManager");
static_assert(offsetof(UTweenManager, TweenContexts) == 0x000038, "Member 'UTweenManager::TweenContexts' has a wrong offset!");

// Class Tweening.TweenSequence
// 0x0068 (0x0090 - 0x0028)
class UTweenSequence final : public UObject
{
public:
	TArray<struct FTweenSequenceEntry>            SequenceEntries;                                   // 0x0028(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UTweenManager*                          TweenManager;                                      // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTimerHandle>                   TimerHandles;                                      // 0x0040(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x40];                                      // 0x0050(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_AppendSequence(class UTweenSequence*& SequenceToAppend, float AdditionalDelayAtBeginning, float AdditionalDelayAtEnd, class UTweenSequence** OutSequence);
	void BP_AppendTween(int32& TweenId, float AdditionalDelayAtBeginning, float AdditionalDelayAtEnd, class UTweenSequence** OutSequence);
	void BP_JoinSequence(class UTweenSequence*& SequenceToAppend, float AdditionalDelayAtBeginning, float AdditionalDelayAtEnd, class UTweenSequence** OutSequence);
	void BP_JoinTween(int32& TweenId, float AdditionalDelayAtBeginning, float AdditionalDelayAtEnd, class UTweenSequence** OutSequence);
	void Play(ETweenPlayDirection InPlayDirection);
	void Stop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TweenSequence">();
	}
	static class UTweenSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTweenSequence>();
	}
};
static_assert(alignof(UTweenSequence) == 0x000008, "Wrong alignment on UTweenSequence");
static_assert(sizeof(UTweenSequence) == 0x000090, "Wrong size on UTweenSequence");
static_assert(offsetof(UTweenSequence, SequenceEntries) == 0x000028, "Member 'UTweenSequence::SequenceEntries' has a wrong offset!");
static_assert(offsetof(UTweenSequence, TweenManager) == 0x000038, "Member 'UTweenSequence::TweenManager' has a wrong offset!");
static_assert(offsetof(UTweenSequence, TimerHandles) == 0x000040, "Member 'UTweenSequence::TimerHandles' has a wrong offset!");

// Class Tweening.WidgetTweening
// 0x0000 (0x0028 - 0x0028)
class UWidgetTweening final : public UBlueprintFunctionLibrary
{
public:
	static void BP_OpacityTo(int32* OutTweenId, class UObject* ContextObject, class UWidget* Target, const struct FTweenOptionalFloat& FromOptions, float ToValue, bool bIsRelative, float duration, const struct FTweenDelayOptions& DelayOptions, ETweenBuiltInEasing EasingFunction, class UCurveFloat* EasingCurve, const struct FTweenLoopOptions& LoopOptions, bool bAutoPlay, bool bAutoKill);
	static void BP_TransformAngleTo(int32* OutTweenId, class UObject* ContextObject, class UWidget* Target, const struct FTweenOptionalFloat& FromOptions, float ToValue, bool bIsRelative, float duration, const struct FTweenDelayOptions& DelayOptions, ETweenBuiltInEasing EasingFunction, class UCurveFloat* EasingCurve, const struct FTweenLoopOptions& LoopOptions, bool bAutoPlay, bool bAutoKill);
	static void BP_TransformPivotTo(int32* OutTweenId, class UObject* ContextObject, class UWidget* Target, const struct FTweenOptionalVector2D& FromOptions, const struct FVector2D& ToValue, bool bIsRelative, float duration, const struct FTweenDelayOptions& DelayOptions, ETweenBuiltInEasing EasingFunction, class UCurveFloat* EasingCurve, const struct FTweenLoopOptions& LoopOptions, bool bAutoPlay, bool bAutoKill);
	static void BP_TransformScaleTo(int32* OutTweenId, class UObject* ContextObject, class UWidget* Target, const struct FTweenOptionalVector2D& FromOptions, const struct FVector2D& ToValue, bool bIsRelative, float duration, const struct FTweenDelayOptions& DelayOptions, ETweenBuiltInEasing EasingFunction, class UCurveFloat* EasingCurve, const struct FTweenLoopOptions& LoopOptions, bool bAutoPlay, bool bAutoKill);
	static void BP_TransformShearTo(int32* OutTweenId, class UObject* ContextObject, class UWidget* Target, const struct FTweenOptionalVector2D& FromOptions, const struct FVector2D& ToValue, bool bIsRelative, float duration, const struct FTweenDelayOptions& DelayOptions, ETweenBuiltInEasing EasingFunction, class UCurveFloat* EasingCurve, const struct FTweenLoopOptions& LoopOptions, bool bAutoPlay, bool bAutoKill);
	static void BP_TranslationTo(int32* OutTweenId, class UObject* ContextObject, class UWidget* Target, const struct FTweenOptionalVector2D& FromOptions, const struct FVector2D& ToValue, bool bIsRelative, float duration, const struct FTweenDelayOptions& DelayOptions, ETweenBuiltInEasing EasingFunction, class UCurveFloat* EasingCurve, const struct FTweenLoopOptions& LoopOptions, bool bAutoPlay, bool bAutoKill);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetTweening">();
	}
	static class UWidgetTweening* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetTweening>();
	}
};
static_assert(alignof(UWidgetTweening) == 0x000008, "Wrong alignment on UWidgetTweening");
static_assert(sizeof(UWidgetTweening) == 0x000028, "Wrong size on UWidgetTweening");

}

