#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MLDeformerRuntime

#include "Basic.hpp"

#include "FortniteGame_classes.hpp"
#include "MLDeformerFramework_classes.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class MLDeformerRuntime.FortMLDeformerComponent
// 0x0020 (0x0100 - 0x00E0)
class UFortMLDeformerComponent final : public UMLDeformerComponent
{
public:
	class UMLDeformerAsset*                       RequestedMLDeformerAsset;                          // 0x00E0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMeshDeformer*                          RequestedMeshDeformerAsset;                        // 0x00E8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x10];                                      // 0x00F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMLDeformerComponent">();
	}
	static class UFortMLDeformerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMLDeformerComponent>();
	}
};
static_assert(alignof(UFortMLDeformerComponent) == 0x000008, "Wrong alignment on UFortMLDeformerComponent");
static_assert(sizeof(UFortMLDeformerComponent) == 0x000100, "Wrong size on UFortMLDeformerComponent");
static_assert(offsetof(UFortMLDeformerComponent, RequestedMLDeformerAsset) == 0x0000E0, "Member 'UFortMLDeformerComponent::RequestedMLDeformerAsset' has a wrong offset!");
static_assert(offsetof(UFortMLDeformerComponent, RequestedMeshDeformerAsset) == 0x0000E8, "Member 'UFortMLDeformerComponent::RequestedMeshDeformerAsset' has a wrong offset!");

// Class MLDeformerRuntime.MLDeformerGameFeatureData
// 0x0008 (0x0538 - 0x0530)
class UMLDeformerGameFeatureData final : public UFortGameFeatureData
{
public:
	bool                                          bDisableWhenOwnerIsNotViewTarget;                  // 0x0530(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldRampUpWeightWhenEnabled;                    // 0x0531(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_532[0x2];                                      // 0x0532(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeightIncreasePerSecond;                           // 0x0534(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MLDeformerGameFeatureData">();
	}
	static class UMLDeformerGameFeatureData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMLDeformerGameFeatureData>();
	}
};
static_assert(alignof(UMLDeformerGameFeatureData) == 0x000008, "Wrong alignment on UMLDeformerGameFeatureData");
static_assert(sizeof(UMLDeformerGameFeatureData) == 0x000538, "Wrong size on UMLDeformerGameFeatureData");
static_assert(offsetof(UMLDeformerGameFeatureData, bDisableWhenOwnerIsNotViewTarget) == 0x000530, "Member 'UMLDeformerGameFeatureData::bDisableWhenOwnerIsNotViewTarget' has a wrong offset!");
static_assert(offsetof(UMLDeformerGameFeatureData, bShouldRampUpWeightWhenEnabled) == 0x000531, "Member 'UMLDeformerGameFeatureData::bShouldRampUpWeightWhenEnabled' has a wrong offset!");
static_assert(offsetof(UMLDeformerGameFeatureData, WeightIncreasePerSecond) == 0x000534, "Member 'UMLDeformerGameFeatureData::WeightIncreasePerSecond' has a wrong offset!");

// Class MLDeformerRuntime.MLDeformerAssetMapping
// 0x0130 (0x0160 - 0x0030)
class UMLDeformerAssetMapping final : public UPrimaryDataAsset
{
public:
	TArray<TSoftObjectPtr<class UAthenaCharacterItemDefinition>> CharacterItemDefinitionToMLDeformerAssetMappingKeys; // 0x0030(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UMLDeformerAsset>> CharacterItemDefinitionToMLDeformerAssetMappingValues; // 0x0040(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UCustomCharacterPart>> CharacterPartToMLDeformerAssetMappingKeys;         // 0x0050(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UMLDeformerAsset>> CharacterPartToMLDeformerAssetMappingValues;       // 0x0060(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<TSoftObjectPtr<class UMLDeformerAsset>, TSoftObjectPtr<class UMeshDeformer>> MLDeformerToMeshDeformerAssetMap;                  // 0x0070(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<TSoftObjectPtr<class UAthenaCharacterItemDefinition>, TSoftObjectPtr<class UMLDeformerAsset>> CharacterItemDefinitionToMLDeformerAssetMap;       // 0x00C0(0x0050)(Deprecated, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<TSoftObjectPtr<class UCustomCharacterPart>, TSoftObjectPtr<class UMLDeformerAsset>> CharacterPartToMLDeformerAssetMap;                 // 0x0110(0x0050)(Deprecated, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MLDeformerAssetMapping">();
	}
	static class UMLDeformerAssetMapping* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMLDeformerAssetMapping>();
	}
};
static_assert(alignof(UMLDeformerAssetMapping) == 0x000008, "Wrong alignment on UMLDeformerAssetMapping");
static_assert(sizeof(UMLDeformerAssetMapping) == 0x000160, "Wrong size on UMLDeformerAssetMapping");
static_assert(offsetof(UMLDeformerAssetMapping, CharacterItemDefinitionToMLDeformerAssetMappingKeys) == 0x000030, "Member 'UMLDeformerAssetMapping::CharacterItemDefinitionToMLDeformerAssetMappingKeys' has a wrong offset!");
static_assert(offsetof(UMLDeformerAssetMapping, CharacterItemDefinitionToMLDeformerAssetMappingValues) == 0x000040, "Member 'UMLDeformerAssetMapping::CharacterItemDefinitionToMLDeformerAssetMappingValues' has a wrong offset!");
static_assert(offsetof(UMLDeformerAssetMapping, CharacterPartToMLDeformerAssetMappingKeys) == 0x000050, "Member 'UMLDeformerAssetMapping::CharacterPartToMLDeformerAssetMappingKeys' has a wrong offset!");
static_assert(offsetof(UMLDeformerAssetMapping, CharacterPartToMLDeformerAssetMappingValues) == 0x000060, "Member 'UMLDeformerAssetMapping::CharacterPartToMLDeformerAssetMappingValues' has a wrong offset!");
static_assert(offsetof(UMLDeformerAssetMapping, MLDeformerToMeshDeformerAssetMap) == 0x000070, "Member 'UMLDeformerAssetMapping::MLDeformerToMeshDeformerAssetMap' has a wrong offset!");
static_assert(offsetof(UMLDeformerAssetMapping, CharacterItemDefinitionToMLDeformerAssetMap) == 0x0000C0, "Member 'UMLDeformerAssetMapping::CharacterItemDefinitionToMLDeformerAssetMap' has a wrong offset!");
static_assert(offsetof(UMLDeformerAssetMapping, CharacterPartToMLDeformerAssetMap) == 0x000110, "Member 'UMLDeformerAssetMapping::CharacterPartToMLDeformerAssetMap' has a wrong offset!");

// Class MLDeformerRuntime.MLDeformerComponentManager
// 0x0028 (0x00C8 - 0x00A0)
class UMLDeformerComponentManager final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x28];                                      // 0x00A0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MLDeformerComponentManager">();
	}
	static class UMLDeformerComponentManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMLDeformerComponentManager>();
	}
};
static_assert(alignof(UMLDeformerComponentManager) == 0x000008, "Wrong alignment on UMLDeformerComponentManager");
static_assert(sizeof(UMLDeformerComponentManager) == 0x0000C8, "Wrong size on UMLDeformerComponentManager");

}

